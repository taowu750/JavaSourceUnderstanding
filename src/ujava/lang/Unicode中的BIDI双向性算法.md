# 1. Unicode 的方向性<sup id="a1">[\[1\]](#f1)</sup><sup id="a2">[\[2\]](#f2)</sup>

## 1.1 文本的方向

大多数语言的文本在水平方向都是按<strong>从左到右(Left To Right，简称LTR)</strong>的顺序显示字符的，
但也有不少语言是按<strong>从右到左(Right To Left，简称RTL)</strong>的顺序显示字符的(比如阿拉伯语、希伯来语)。
当然还有按垂直方向书写的文本，比如中国古代的汉字就是从上到下从右到左书写的，本文只讨论水平方向书写的文本，垂直方向书写的文本不予讨论。

双向文本是指一个字符串中同时包含`LTR`和`RTL`的文本，既包含从左到右的文本又包含从右到左的文本。现实中，
从右向左书写的语言通常会夹杂着从左向右的文本(比如外语、引用、数字、符号等)，因此，像阿拉伯语、希伯来语这些语言通常都是双向文本。
另外，当在从左向右的文本中插入从右向左的文本时也会产生双向文本的问题。

## 1.2 逻辑顺序与显示顺序

**逻辑顺序**在`Unicode`标准内规定为文本在内存中表示的顺序，而**显示顺序**就是最终显示在我们面前所看到的文本的顺序，
文本的逻辑顺序和显示顺序并不一定会一致，比如对于从右向左显示的文本，显示顺序应是从右向左的，而逻辑顺序则可能是从左向右的。
逻辑顺序是属于计算机底层的问题，不属于本文讨论的范围，我们需要解决的是文本的显示顺序题。

## 1.3 方向性作用范围

### 1.3.1 基础方向

定义的是一个区域的整体方向，例如一个页面、一个段落或一个句子。中英文环境一般是(LTR)从左至右，而阿拉伯文环境则为(RTL)右至左的书写顺序。

### 1.3.2 字符方向

日常我们书写文字会知道，书写的方向是决定于所书写的文字，汉字、拉丁文字是从左至右，阿拉伯文、希伯来文则是从右至左。相应的，
`Unicode`字符在设计时就考虑了不同文字方向性的问题，因此定义了每个`Unicode`字符的方向属性。

# 2. Unicode双向算法(bidi)与定向格式化字符
1. 对于双向文本，若不明确的确定文本的显示顺序，在显示时就可能会出现歧义，为此，需要为双向文本的显示定义一种算法(或者一种规则)，
用于规范双向文本的显示顺序。
2. 通常有一种**隐式算法**(或称为隐式双向排序或隐式布局算法)来定义双向文本的显示，但是隐式算法并不足以产生可供理解的文本，
为此，对某些字符的显示顺序需要明确地进行控制，就是使用一系列的**控制符**(类似于HTML中的元素)来控制字符的显示顺序，
这些控制符被`Unicode`称为**定向格式化字符**。比如，使用`RLO`控制符来控制字符从右向左显示，`PDF`表示`RLO`的终止字符，
那么ab cd **RLO** EF GH **PDF** x，将被显示为ab cd HG FE x，可见，`Unicode`控制符的原理与`HTML`的元素是相似的。
3. 定向格式化字符只影响文本的显示顺序，在其它方面会被忽略，也就是说定向格式化字符不会对文本的比较、断句、词法分析、
数值分析等方面造成影响。
4. `Unicode`双向算法(也称为`BIDI`)是对隐式算法的扩展， `Unicode`双向算法定义了定向格式化字符(即控制符)，并且定义了一套算法，
用于规定这些控制符对需要显示的字符产生怎样的影响。

# 3. 双向字符类型

`Unicode`为每个`Unicode`字符都定义了一种类型(称为**双向字符类型或`BIDI`类型**)，双向字符类型被分为：强字符(强类型)、弱字符(弱类型)、
中性字符(中性类型)、定向格式化字符。

## 3.1 类型

![字符的方向类型][bidi-type]

1. Strong 强字符： 方向性确定，`LTR`或`RTL`，和上下文无关。并且可能会影响其前后字符的方向性。
2. Weak 弱字符： 和强字符一样方向性也是确定的，但是不会影响前后字符的方向性。
3. Neutral 中性字符： 方向性不确定，由上下文环境决定其方向。

##  3.2 定向格式化字符

定向格式化字符是`Unicode`标准中定义了一系列方向性控制字符，这些字符在界面上不显示，也不占用任何展示空间。它们像是一些标记，
影响着`BIDI`双向算法对文字书写方向的判断。

字向格式化字符分为**隐式定向格式化字符**和**显示定向格式化字符**两大类。显示定向格式化字符又分为显示定向*嵌入*格式化字符、
显示定向*重写*格式化字符、显示定向*隔离*格式化字符，分别简称为嵌入格式化字符、重写格式化字符、隔离格式化字符。
其中隔离格式化字符是在`Unicode 6.3`中引入的。

![定向格式化字符][direct-control]

### 3.2.1 隐式双向控制字符 (Implicit Markers)

隐式控制字符的概念比较简单，可以理解为一个不会展示出来的强字符，`LRM`为从左到右的强字符，而`RLM`为从右到左的强字符。

### 3.2.2 显式双向控制字符 (Explicit Markers)

显式控制字符需要成对使用，前四个字符`LER` `RLE` `LRO` `RLO`为开始字符，最后一个`PDF`为结束字符。
1. `LRE`&`RLE` : 接下来的文字片段内的方向变为 从左至右 / 从右至左。效果类似基础方向，将一段文本中的基础方向变更。
2. `LRO`&`RLO` : 顾名思义 override，接下来的所有`Unicode`字符的方向性将被覆盖为 从左至右强字符 / 从右至左强字符。

# 4. 实例

一切得从复制 iOS 通讯录联系人手机号说起，有同学发现复制的号码是 "(415)555-3695"，长度应该是 13，但 Debug 打印的长度却是 15，WTF？

通过断点发现是前后分别多了一个不知何用 Unicode 字符:

![ios 复制多出来的字符][ios-phone]

这两个都是关于方向的`Unicode`控制字符，U+202D 简称`LRO`，U+202C 简称`PDF`。

## 4.1 Unicode 字符方向串

下面我们先把这两个控制字符从号码中去掉，仅将 "(415)555-3695" 套用到阿拉伯文和中英文环境，观察会出现哪些问题：

![不同环境下的电话号码显示][diff-env]

可以看到在中英文环境中，文本、数字和标点符号都按照从左至右的顺序书写，展示正常。但在阿拉伯文环境中，
电话号码好像按符号分割分组并方向展示了，这是怎么回事？这里要引入<strong>方向串(Directional Run)</strong>的概念，
是指在一段文字中具有相同方向性的连续字符，并且其前后没有相同方向性的其它方向串。全局方向、文本中的字符强弱类型决定了如何分割方向串，
以上面的例子做分析：

![方向串][direct-run]

文本被分为 6 个不同的方向串，问题显而易见，由于中性符号被全局方向影响，使得原本号码被拆分成不同方向串，被重新排序。

## 4.2 使用隐式双向控制字符

我们可以在每个中性字符 '-'、'('、')' 左右用`LTR`字符包裹，这样中性字符被左至右的强字符包裹，它的方向也应该会变为从左至右。
尝试一下 (阿拉伯文手机的 Unicode 编码为 U+0647 U+0627 U+0062a U+0641 )：
```html
<!-- dir=rtl 设置 div 中的基础方向为从右至左 -->
<div dir="rtl">
    &#x647;&#x627;&#x062a;&#x641;: &#x200e;(&#x200e;415&#x200e;)&#x200e;555&#x200e;-&#x200e;3695
</div>
```
![使用隐式双向控制字符的效果][implicit]

可以看到，成功解决了问题。但是这样过于繁琐，毕竟 iOS 实现相同效果只用了`LRO`和`PDF`两个字符。

## 4.3 使用显式双向控制字符

### 4.3.1 LRE

还以上面的通讯录文本为例：
```html
<!-- 基础方向为从右至左 -->
<div dir="rtl">
    <!-- 使用 LRE 将号码部分文本方向改为从左至右 -->
    &#x647;&#x627;&#x062a;&#x641;: &#x202a;(415)555-3695&#x202c;
</div>
```
![应用 LRE][lre]

### 4.3.2 LRO

```html
<!-- 基础方向为从右至左 -->
<div dir="rtl">
    <!-- 使用 LRO 将号码部分文本方向改为从左至右 -->
    &#x647;&#x627;&#x062a;&#x641;: &#x202d;(415)555-3695&#x202c;
</div>
```
![应用 LRO][lro]

### 4.3.3 它们的应用场景

`LRE`/`RLE`和`LRO`/`RLO`有什么区别，用在什么不同场景呢？接着看例子：

```html
<!-- 基础方向为从左至右 -->
<div dir="ltr">
    <div> here left to right, here right to left. </div>
    <div> here left to right&#x202b;, here right to left.&#x202c; </div>
    <!-- 后半部分因为 RLE 使得文本方向改变 ',''.' 符号书写顺序变为从右至左 -->
</div>
```
![LRE 的作用效果][diff-lre]

```html
<!-- 基础方向为从左至右 -->
<div dir="ltr">
    <div> here left to right, here right to left. </div>
    <div> here left to right&#x202b;, here right to left.&#x202c; </div>
    <!-- 后半部分因为 RLO 使得字符方向属性被覆盖为强字符从右至左，英文字母也变成了从右至左书写 -->
</div>
```
![lro 的作用效果][diff-lro]

# 5. 运行等级和隔离运行序列

## 5.1 基本名词

1. 嵌入等级(或嵌入水平)：表示字符的嵌入层次，数字越大嵌入得越深，需要注意的是，在`BIDI`算法中，字符串中的每个字符都有一个嵌入等级。
2. 隔离启动器：是对`LRI`、`RLI`、`FSI`的统称，注意：隔离启动器不包括`PDI`
3. 嵌入启动器：是对`LRE`、`RLE`、`LRO`、`RLO`的统称，注意：嵌入启动器不包括`PDF`

## 5.2 定义

1. 运行等级(level run)：也称为<strong>定向运行(directional run)</strong>，就是第4节说到的运行串。
是指具有相同嵌入等级的字符所形成的最大子串，该子串与其直接接触的前后字符的嵌入等级不相同，比如 ab cd **RLE** ef gh **PDF** kk mm，
假设分段的嵌入等级为0，则字符 a、b、c、d (含其中的空格)的嵌入等级都为0，字符 e、f、g、h 的嵌入等级都为1，
字符 k、k、m、m 的嵌入等级为0，因此，该字符串共有3个运行等级，分别是子串 ab cd，子串 ef gh，子串 kk mm。
2. 隔离运行序列(简称为运行序列或序列)：是由一系列运行等级组成的序列，其规则如下：
    - 含有隔离启动器时：除最后一个运行等级外，隔离运行序列中运行等级的最后一个字符是隔离启动器，
    与该隔离启动器匹配的`PDI`是序列中下一个运行等级的第一个字符，也就是说，序列中的运行等级是以隔离启动器结束的(最后一个运行等级除外)，
    以PDI开始的(除第一个运行等级外)。
    - 无隔离启动器时：此时每个运行等级构成一个独立的隔离运行序列。
3. 隔离运行序列具有如下特点：
    - 每个运行等级只属于一个隔离运行序列，也就是说，不存一个运行等级属于两个序列的情形。
    - 在同一个隔离运行序列中所有的运行等级具有相同的嵌入等级，因为隔离运行序列是以隔离启动器开始一个运行等级，
    又以与其匹配的`PDI`开始另一个运行等级，很明显，这两个运行等级具有相同的嵌入等级。
    - 紧随着隔离启动器之后的运行等级会开启一个新的隔离运行序列，与之匹配的`PDI`之前的运行等级会结束它的隔离运行序列。
4. 隔离启动器的重要规则：隔离启动器和与其匹配的`PDI`拥有的嵌入等级是提升之前的原始嵌入等级，而不是提升之后的嵌入等级。

## 5.3 示例

以下示例的“文本”表示实际输入的内容，其中的符号“⋄”不属于文本的内容，该符号只是为了提高示例的清晰度，以方便阅读。
以下示例均假设分段的嵌入等级为 0。

### 5.3.1 示例1（含隔离启动器）

文本1 ⋄ **RLI** ⋄ 文本2 ⋄ *PDI* ⋄ 文本3 ⋄ **RLI** ⋄ 文本4 ⋄ *PDI* ⋄ **RLI** ⋄ 文本5 ⋄ *PDI* ⋄ 文本6 

1. 运行等级的分析方法：
    - |文本1 ⋄ RLI| 构成一个运行等级，因为在RLI之后的 |文本2| 与 |文本1 ⋄ RLI| 的嵌入等级不相同，|文本1 ⋄ RLI| 的嵌入等级为0，
    而 |文本2| 的嵌入等级为1，因此 |文本1 ⋄ RLI| 构成一个运行等级，其等级为0。此处应用了规则：
    `RLI`和与之匹配的`PDI`的嵌入等级是提升之前的嵌入等级。
    - |文本2| 构成一个运行等级，因为在 |文本2| 之前的`RLI`和之后的`PDI`与 |文本2| 的嵌入等级不相同，
    |文本2| 之前的`RLI`和之后的`PDI`的嵌入等级都为0，而 |文本2| 的嵌入等级为1，因此，|文本2| 构成一个运行等级。
    - 其余运行等级的分析方法与以上类似，不再重述。
2. 隔离运行序列的分析方法：
    - |文本1 ⋄ RLI| 为隔离运行序列中的一个运行等级(以`RLI`结束)，与该`RLI`匹配的`PDI`，即 |文本2| 之后的`PDI`是该序列中的下一个运行等级的开始，
    因此 |PDI ⋄ 文本3 ⋄ RLI| 是该隔序运行序列中的下一个运行等级(以`RLI`结束)，同理，|文本4| 之后的 |PDI ⋄ RLI| 是该序列中的再下一个运行等级，
    |PDI ⋄ 文本6| 是该序列中的最后一个运行等级，因此，第一个隔离运行序列中的运行等级包含 |文本1 ⋄ RLI|、
    |PDI ⋄ 文本3 ⋄ RLI|、|PDI ⋄ RLI|、|PDI ⋄ 文本6| 四个运行等级。
    - |文本2| 独自构成一个隔离运行序列，因为，紧随着隔离启动器之后的运行等级会开启一个新的隔离运行序列，
    与之匹配的`PDI`之前的运行等级会结束它的隔离运行序列。|文本2| 位于 |文本1 ⋄ RLI| 中的`RLI`之后，
    同时位于 |PDI ⋄ 文本3 ⋄ RLI| 中的`PDI`之前，因此 |文本2| 独自构成一个隔离运行序列。
    - 其余隔离运行序列的分析方法与以上相同，不再重述。

最终的运行等级和隔离运行序列如下所示：
1. 运行等级(共有7个)：  
    |文本1 ⋄ RLI| → 等级0  
    |文本2| → 等级1  
    |PDI ⋄ 文本3 ⋄ RLI| → 等级0  
    |文本4| → 等级1  
    |PDI ⋄ RLI| → 等级0  
    |文本5| → 等级1  
    |PDI ⋄ 文本6| → 等级0  
2. 隔离运行序列(共有4个):  
    |文本1 ⋄ RLI| |PDI ⋄ 文本3 ⋄ RLI| |PDI ⋄ RLI| |PDI ⋄ 文本6| → 等级0  
    |文本2| → 等级1  
    |文本4| → 等级1  
    |文本5| → 等级1  

图1为运行等级和隔离运行序列的图形表示法，等级=0的隔离运行序列由4个运行等级组成(虚线上方对应的运行等级)，
小括号范围内的运行等级不属于该隔离运行序列，等级=1的隔离运行序列虽然是画在同一行上的，
但表示的是3个等级=1的隔离运行序列而不是一个由多个运行等级组成的等级=1的隔离运行序列，
等级=0的隔离运行序列才表示的是一个由多个运行等级组成的隔离运行序列。

![图形法表示运行等级和隔离运行序列][iso]

### 5.3.2 示例2（不含隔离启动器）

分析如下文本的运行等级和隔离运行序列，本示例主要是要明白以下分段1的文本与分段2和分段3的文本的隔离运行序列的区别：

分段1：文本1 ⋄ RLE ⋄ 文本2 ⋄ PDF ⋄ RLE ⋄ 文本3 ⋄ PDF ⋄ 文本4<br>
分段2：文本1 ⋄ RLE ⋄ 文本2 ⋄ PDF ⋄ 文本3 ⋄ RLE ⋄ 文本4 ⋄ PDF ⋄ 文本5<br>
分段3：文本1 ⋄ RLI ⋄ 文本2 ⋄ PDI ⋄ RLI ⋄ 文本3 ⋄ PDI ⋄ 文本4<br>

各分段的图形表示法分别如图2、图3、图4所示：

![分段1图形表示法][iso-seg1]

![分段2图形表示法][iso-seg2]

![分段3图形表示法][iso-seg3]

# 6. BIDI 算法阐述

## 6.1 BIDI 算法基本规则和思想

再次提醒：在`BIDI`算法中定向格式化字符是作为一个字符处理的，比如a LRE b，这里共有3个字符，分别是a、LRE、b。

强字符的方向是确定的，要么为从左向右(称为L类型)，要么为从右向左(称为R类型)，其中AL类型视为R类型。

最终类型(在不引起混淆的情况下，本文有时会将其简称为类型)：`BIDI`算法会把每个字符(包括定向格式化字符)都转换为 L、R、EN、AN 四种类型之一，
因此，最终类型是指字符的 L、R、EN、AN 类型。

`BIDI`算法规定(这是强制规定)：L 类型字符的嵌入等级必须是偶数，R 类型字符的嵌入等级必须是奇数，若不满足以上要求，
需对字符的嵌入等级进行调整(调整规则见`I1~I2`算法)或作硬性规定，此规则，通常可以反过来理解(注：字符串含有 EN、AN 时就不能这样理解了)，
即，最终的嵌入等级若是奇数，则该字符是 R 类型，若是偶数，则该字符是 L 类型。同理，运行等级，分段的嵌入等级也需要满足此规定。

`BIDI`算法的一个基本思想是，首先确定各个字符的嵌入等级，然后，把所有字符都调整为 L、R、EN、AN 四种类型之一，
并根据字符的这些类型调整字符的嵌入等级为偶数或奇数，然后对调整后具有相同嵌入等级组成的子串进行重排序并显示。也就是说，
所有的字符类型，比如 ON、LRI、WS、NSM 等最后都会被调整为 L、R、EN、AN 四种类型之一。

总体来讲，bidi算法分为4大步，即，
1. 初次确定各字符的嵌入等级(P、X系列算法)
2. 调整字符为L、R、EN、AN四种类型之一(W、N系列算法)，即，把字符的类型调整为最终类型
3. 调整嵌入等级 ( I系列算法)，调整后的嵌入等级为最终嵌入等级
4. 重排序(L系列算法)。

## 6.2 周围字符的类型对字符最终类型的影响及 BIDI 调整字符类型的方法

bidi算法调整字符类型的方法是根据该字符周围字符的类型对该字符的类型进行调整，也就是说，周围字符的类型会对该字符的最终类型产生影响，
具体的调整算法详见W和N系列算法。

### 6.2.1 强字符、弱字符、中性字符对周围字符的影响

1. 强字符会对其前后的中性字符的最终类型产生影响，除L类型的强字符会对之后的EN字符(欧洲数字，弱类型)的最终类型产生影响外，
强字符不会对弱字符的最终类型产生影响。从表1可见，大部分的字符都是强字符，比如，阿拉伯字符(从右到左)，汉字(从左到右)、
英文字符(从左向右)等。
2. 中性字符不会影响周围文本的最终类型，大部分的标点符号和空格都是中性字符，比如符号“;”，“[”，“)”等都是中性字符
3. 弱字符不会对其前后字符的最终类型产生影响，数字就是弱字符。

### 6.2.2 定向格式化字符对周围字符的影响

1. 隔离(LRI、RSI、FSI)范围内的字符不会影响到外部字符的排序，反之亦然。隔离范围内的字符作为一个整体对周围字符的影响与中性字符相同。
2. 嵌入(LRE、RLE)范围内的字符会影响到外部字符的排序，反之亦然。嵌入内的字符作为一个整体对周围字符的影响与强字符相同。
由于嵌入会对周围字符产生很强的影响从而导致新的问题，因此在支持隔离的平台上，建议使用隔离而不是嵌入。
3. 重写格式化字符可以强制改变文本的书写方向，因此存在着安全问题，除非特殊情况，否则不应使用重写格式化字符`RLO`、`LRO`。
重写范围内的字符作为一个整体对周围字符的影响与强字符相同。

## 6.3 BIDI 算法总体概述

### 6.3.1 BIDI 算法组成

`BIDI`算法由多个算法组成，每个算法都有一个名称，每个算法又包含多个子算法或步骤，比如 P 系列算法，共有 P1、P2、P3 三个步骤，
P 系列算法是解析字符顺序时的第一步。下面为bidi的各种算法及其作用：
1. P 系列算法用于解析分段的嵌入等级
2. X 系列算法用于解析分段中各个字符的嵌入等级，此步骤解析出的字符并不一定满足 L 类型的嵌入等级为偶数，R 类型为奇数的规则，
需在 I 系列进行调整。
3. W 系列算法用于解析弱字符的类型，即调整弱字符的类型为最终类型
4. N 系列算法用于中性和隔离格式化字符的类型为最终类型
5. I 系列算法用于调整各字符的嵌入等级为奇数或偶数。
6. L 系列算法用于重排序

### 6.3.2 BIDI算法步骤

以下为使用`BIDI`算法的步骤，及各系列算法的主要规则：
1. 步骤1：算法编号 P1~P3  
    把文本分成段，然后以段为作用域进行后续算法的处理。若段的方向为从左向右(即L)，则分段的嵌入等级为0(偶数)，
    若段的方向为从右向左(即 R)，则分段的嵌入等级为1(奇数)。通常，在分段的嵌入等级确定后，还需要解析出各字符在调整之前的`BIDI`类型
2. 步骤2：算法编号 X1~X10  
    计算出各字符原始的、调整之前的嵌入等级，在该系列算法中，还会确定出运行等级和隔离运行序列，该步骤的几种基本规则如下：
    - RLE、LRE、RLI、LRI、FSI、LRO、RLO 会提升之后的字符的嵌入等级，具体怎样提升的，详见下一小节对 X 系列算法的讲解。
    - PDF、PDI 会把之后字符的嵌入等级还原到之前的嵌入等级。
    - 算法 X9 规定，RLE、LRE、RLO、LRO、PDF、BN 会被移除，移除后这些了符只会作为占位符，在之后的分析中，
    这些字符表现得就像不存在一样，但是 FSI、LRI、RLI、PDI 不会被移除，由于对嵌入等级和字符类型的调整都是在该步骤之后，
    所以 RLE、LRE、RLO、LRO、PDF、BN 这些字符对整个字符排序的影响可忽略，其嵌入等级可不考虑，当使用图形法分析时，
    这些字符的嵌入等级使用 x 代替
3. 步骤3：算法编号 W1~W7。把弱字符调整为 L、EN、AN、ON 四种类型之一。
4. 步骤4：算法编号 N0~N2。把中性和隔离格式化字符调整为 L 或 R 类型
5. 步骤5：算法编号 I1~I2。根据各个字符的 L 或R类型调整各字符的嵌入等级，在此步骤之前确定的字符的 L 类型不一定是偶数，
同理 R 类型也不一定是奇数，该步骤的主要作用是把 L 类型的嵌入等级调整为偶数，R 类型的嵌入等级调整为奇数，其方法比较简单，
就是把不符合要求的字符的嵌入等级加1即可。该步骤的调整并不会影响之前确定的运行等级。
6. 步骤6：算法编号 L1~L4。重排序具有相同嵌入等级的子串，并显示。该步骤的主要算法为：从嵌入层次最深的子串开始将所有字符进行反转
(即，所有字符按从右向左排序输出)，嵌入多少层就重复多少次该操作，比如，"ab cd ef"嵌入的层次为3层(即嵌入等级为3)，
则第1次反转为 fe dc ab，第2次在第1次反转后的结果上反转为 ab cd ef，第3次在第2次的基础上反转为 fe dc ba，最后显示为 fe dc ba

[BIDI 算法详解请参见这个链接。][bidi-detail]


[bidi-type]: ../../../res/img/char-bidi-type.png
[direct-control]: ../../../res/img/char-directional-control.png
[ios-phone]: ../../../res/img/char-ios-phone.png
[diff-env]: ../../../res/img/char-diff-env.png
[direct-run]: ../../../res/img/char-directional-run.png
[implicit]: ../../../res/img/char-implicit.png
[lre]: ../../../res/img/char-lre.png
[lro]: ../../../res/img/char-lro.png
[diff-lre]: ../../../res/img/char-diff-lre.png
[diff-lro]: ../../../res/img/char-diff-lro.png
[iso]: ../../../res/img/char-isolation-starter.png
[iso-seg1]: ../../../res/img/char-isolation-segment1.png
[iso-seg2]: ../../../res/img/char-isolation-segment2.png
[iso-seg3]: ../../../res/img/char-isolation-segment3.png
[bidi-detail]: https://blog.csdn.net/hyongilfmmm/article/details/102780470

<b id="f1">1.</b> 参考 https://www.jianshu.com/p/6aa9061ffa42。 [↩](#a1)  
<b id="f2">2.</b> 参考 https://mp.weixin.qq.com/s/_v5bfQz-AwuBJHzEC4_q0Q。 [↩](#a2)