# 1. 前言

在`java.lang.Object`类中，可以看到如下代码：
```java
protected native Object clone() throws CloneNotSupportedException

public final native void notify();

public final native void notifyAll();
```
这些方法都没有方法体，并且被`native`关键字修饰。

# 2. 概念

`native`关键字说明其修饰的方法是一个**本地方法**，方法对应的实现不是在当前文件，而是在用其他语言（如`C/C++`）实现的文件中。
`Java`语言本身不能对操作系统底层进行访问和操作，但是可以通过`JNI`接口调用其他语言来实现对底层的访问。

本地方法意味着和平台有关，因此使用了`native`的程序可移植性都不太高。另外`native`方法在`JVM`中运行时数据区也和其它方法不一样，
它有专门的本地方法栈。`native`方法主要用于加载文件和动态链接库，由于`Java`语言无法访问操作系统底层信息（比如：底层硬件设备等），
这时候就需要借助`C/C++`语言来完成了。

`JNI`是`Java`本机接口（Java Native Interface），是一个本机编程接口，它是`Java`软件开发工具箱
（Java Software Development Kit，SDK）的一部分。`JNI`允许`Java`代码使用以其他语言编写的代码和代码库。
`Invocation API`（`JNI`的一部分）可以用来将`Java`虚拟机（`JVM`）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用`Java`代码。

# 3. native 使用流程

1. 编写带有`native`声明的方法的`Java`类。
2. 使用`javac`命令编译编写的`Java`类，生成`class`文件。
3. 使用`javah -jni ***`编译上一步生成的`class`文件，来生成后缀名为`.h`的头文件。
4. 使用其他语言（`C/C++`），实现上一步生成的头文件中的本地方法。
5. 将本地方法文件编译成动态链接库dll。
6. 最后就可以使用`System`或是`Runtime`中的`loadLibrary()`方法加载上一步的产生的动态连接库文件。

# 4. 例子

## 4.1 Java 文件
```java
class HelloWorld{

    // 本地方法
    public native void hello(String name);

    static {
        // 加载动态链接库
        System.loadLibrary("hello");
    }

    public static void main(String[] args){
        new HelloWorld().hello("jni");
    }
}
```

## 4.2 生成头文件

`javac`命令编译生成`class`文件：
```
javac HelloWorld.java
```

`javah`命令编译生成头文件：
```
javah -jni HelloWorld
```

头文件内容：
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
* Class:     HelloWorld
* Method:    hello
* Signature: (Ljava/lang/String;)V
*/
JNIEXPORT void JNICALL Java_HelloWorld_hello(JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

## 4.3 实现本地方法
```c
#include <jni.h>
#include "HelloWorld.h"
#include <stdio.h>

JNIEXPORT void JNICALL Java_HelloWorld_hello(JNIEnv *env,jobject obj, jstring name) {
	const char *str; 
	str = (*env)->GetStringUTFChars(env, name, NULL); 
	if (str == NULL) { 
	    return; 
	}
	printf("Hello World! %s \n", str );
	return;
}
```

## 4.4 生成动态链接库
```
cl -I%java_home%\include -I%java_home%\include\win32 -LD HelloWorldImp.c -Fehello.dll

gcc -m64 -Wl,--add-stdcall-alias -I"C:\Program Files\Java\jdk1.8.0_131\include" -I"C:\Program Files\Java\jdk1.8.0_131\include\win32" -shared -o hello.dll hello.c
```
注意：生成的dll文件名在选项`-Fe`后面配置，这里是`hello`，因为在`HelloWorld.java`文件中我们`loadLibrary`的时候使用的名字是`hello`。
另外需要将`-I%java_home%\include -I%java_home%\include\win32`参数加上，因为在第四步里面编写本地方法的时候引入了`jni.h`文件。