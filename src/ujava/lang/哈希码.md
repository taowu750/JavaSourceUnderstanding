`HaspMap`中使用的hash表下标计算公式是：`(n - 1) & hash`，[其中`n`是2的幂][surplus]。
`n`是hash表的长度，这个式子等同于`hash % n`。我们需要尽可能保证`hashCode`不重复。

Java中散列算法的结果等价于下面的等式：
> s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]

其中`n`是因子个数，`s[i]`是第`i`个参与散列计算的因子。可以看到，它们都乘以了**31**这个素数。
之所以使用素数，是因为[素数在做取模运算时，余数的个数是最多的][prime]。
上面的hash的计算表达式里相当于每项都有了素数，那么`hash % n`时也就近似相当于素数对n取模，
这个时候余数也就会尽可能的多。

既然素数越大越好，素数又那么多，为什么要选择31？这个结论是个数学上的结论，但是实际上，
我们写程序又不能选择太大的素数毕竟`hashCode`的值为`int`类型，计算结果不能溢出。
之所以选择31，一是因为计算机计算31比较快（可以直接采用位移操作得到 1<<5-1），
二是因为大多数情况下我们都是采用`String`作为key，而这又是英语国家写出来的语言，
曾有人对超过5W个英文单词做了测试,在常量取31情况下,碰撞的次数都不超过7次。

<!-- TODO: 仍需要深入理解 hashCode -->

[surplus]: https://www.jianshu.com/p/0711e9eb8cef
[prime]: https://blog.csdn.net/afei__/article/details/83010897