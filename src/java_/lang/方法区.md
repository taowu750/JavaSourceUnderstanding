# 1. 前言

`JVM`的内存空间（运行时数据区）被分为多个不同的区域：堆、方法区、栈、程序计数器、本地方法栈。<sup id="a1">[\[1\]](#f1)</sup>

![运行时内存区域][rda]

本文是基于`HotSpot`来学习说明的。方法区是堆上的一个概念，具体的落地实现是**永久代**或者**元空间**，它们都统称方法区。

# 2. 方法区概述

## 2.1 理解

方法区是一块独立于`Java`堆的内存空间，它主要是用来存储所加载的类信息。《Java虚拟机规范》中明确说明：
“尽管所有的方法区在逻辑上是属于堆的一部分，但些简单的实现可能不会选择去进行垃圾收集或者进行压缩”。对`HotSpot`而言，
方法区还有一个别名叫做 Non-Heap（非堆）。

 - 方法区（Method Area）同堆区一样，是各个线程共享的内存区域
 - 方法区和堆区都是在实际的物理内存空间中，可以是不连续的
 - 方法区的大小和堆空间一样可以动态调整或者固定
 - 方法区的大小决定了系统可以加载多少个类。如果系统定义的类太多，可能会产生`OOM`。例如加载了大量的第三方`jar`包、
 `Tomcat`部署的工程过多，就会产生这种情况。
 - 关闭`JVM`就会释放方法区的内存。
 
## 2.2 从线程的角度来看运行时数据区

![从线程的角度来看运行时数据区][thread]

## 2.3 创建对象各部分所处区域

![创建对象各部分所处区域][new-obj]

## 2.4 方法区的演进

### 2.4.1 演进

首先需要明确的是，只有`HotSpot`才有永久代。BEA JRockit、IBM J9 等来说，是不存在永久代的概念的。
原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。

`HotSpot`中方法区的变化：
1. `jdk1.6`及之前：有永久代（permanent generation），字符串常量池、静态变量存放在永久代上。
2. `jdk1.7`：有永久代，但已逐步去永久代，字符串常量池、静态变量现在都存放在堆上。
3. `jdk1.8`及以后：无永久代，类型信息、字段、方法、常量保存在本地(native)内存的元空间上，但字符串常量池、
静态变量仍存放于堆。

在`JDK7`及以前，习惯上把方法区，称为永久代。`JDK8`开始，使用元空间取代了永久代。
1. 当年使用永久代，更容易导致`Java`程序更容易`OOM`。永久代仍然使用的是`Java`虚拟机的内存
2. 在`JDK8`中，类的元数据现在存储在本地内存中，这个空间被称为元空间。
3. 元空间的本质和永久代类似，都是对`JVM`规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，
而是使用本地内存。

![JDK7][jdk7]

![JDK8][jdk8]

### 2.4.2 原因

根据 Oracle 官方的说法，这是`JRockit`和`HotSpot`聚合工作的一部分。`JRockit`客户不需要配置永久代（因为`JRockit`没有永久代）。
而且因为永久代使用的是虚拟机的内存，为永久代设置空间大小是很难确定的，而元空间的大小仅受本地内存限制。对永久代进行调优是很困难的。

## 2.5 方法区的设置和 OOM

元数据区大小可以使用参数`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`指定替代永久代原有的两个参数。
默认值依赖于平台。windows下，`-XX:MetaspaceSize`是 21M，`-XX:MaxMetaspaceSize`的值是 -1，即没有限制。
元空间与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。
如果元数据区发生溢出，虚拟机一样会抛出异常`OutOfMemoryError：Metaspace`。

溢出时抛出的异常在`JDK8`之前有所不同：
1. `JDK7`及之前：`java.lang.OutOfMemoryError：PermGen`
2. `JDK8`及之后：`java.lang.OutOfMemoryError：Metaspae`

# 3. 方法区内部结构

类加载器将`class`文件加载到内存之后，将类的信息存储到方法区中。方法区中存储的内容有类信息（类型信息、域信息、方法信息）和运行时常量池。

## 3.1 类信息

### 3.1.1 类型信息

对每个加载的类型（类`Class`、接口`interface`、枚举`enum`、注解`annotation`），`JVM`必须在方法区中存储以下类型信息：
 - 这个类型的完整有效名称（全名 = 包名.类名）。
 - 这个类型直接父类的完整有效名（对于`interface`或是`java.lang.Object`，都没有父类）。
 - 这个类型的修饰符（`public`,`abstract`，`final`的某个子集）。
 - 这个类型直接接口的一个有序列表。
 
### 3.1.2 域信息

域信息，即为类的属性，成员变量。`JVM`必须在方法区中保存类所有的成员变量相关信息及声明顺序。
域的相关信息包括：域名称、域类型、域修饰符（`pυblic`、`private`、`protected`、`static`、`final`、`volatile`、`transient`的某个子集）。

### 3.1.3 方法信息

`JVM`必须保存所有方法的以下信息，同域信息一样包括声明顺序：
 - 方法名称方法的返回类型（或`void`）
 - 方法参数的数量和类型（按顺序）
 - 方法的修饰符`public`、`private`、`protected`、`static`、`final`、`synchronized`、`native`、`abstract`的一个子集
 - 方法的字节码`byteCodes`、操作数栈、局部变量表及大小（`abstract`和`native`方法除外）
 - 异常表（`abstract`和`native`方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、
 被捕获的异常类的常量池索引。
 
## 3.2 运行时常量池

有关运行时常量池的内容参见[常量池.md][constant-pool]。


[rda]: ../../../res/img/method-area-rda.png
[thread]: ../../../res/img/method-area-thread.png
[new-obj]: ../../../res/img/method-area-new-obj.png
[jdk7]: ../../../res/img/method-area-jdk7.png
[jdk8]: ../../../res/img/method-area-jdk8.png
[constant-pool]: 常量池.md

<b id="f1">\[1\]</b> 参考 https://blog.csdn.net/weixin_43232955/article/details/107411378。 [↩](#a1)