# 1. 进程

## 1.1 概念

我们都知道计算机的核心是 CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，
统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。

在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了<strong>进程(Process)</strong>的概念，
以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，
是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。

为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为**进程控制块(Process Control Block, PCB)**。
系统利用`PCB`来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由**程序段、数据段和PCB**三部分构成了进程映像（进程实体）。
程序段用于描述进程要完成的功能，是控制进程执行的指令集；数据段是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息，
**PCB是进程存在的唯一标志**。所谓创建进程，实质上是创建进程映像中的`PCB`；而撤销进程，实质上是撤销进程的`PCB`。
值得注意的是，进程映像是静态的，进程则是动态的。

从不同的角度，进程可以有不同的定义，比较典型的定义有：
 - 进程是程序的一次执行过程。
 - 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
 - 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。

在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为:
“**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。**”

## 1.2 特征

进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，
也是对进程管理提出的基本要求。
 - 动态性：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。
 动态性是进程最基本的特征。
 - 并发性：指多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。
 引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。
 - 独立性：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立`PCB`的程序都不能作为一个独立的单位参与运行。
 - 异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进。
 异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。
 - 结构性：每个进程都配置一个`PCB`对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。
 
## 1.3 进程的状态和转换

进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。
通常进程有以下五种状态，前三种是进程的基本状态：
 - 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。
 - 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。
 - 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。
 即使处理机空闲，该进程也不能运行。
 - 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的`PCB`，
 并向`PCB`中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源；最后把该进程转入到就绪状态。
 - 结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，
 系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。
 
注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源
（除了处理机）或等待某一事件。之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，
每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的；
而其他资源（如外设）的使用和分配或者某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。
这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，很显然需要加以区分。

下图说明了五种进程状态的转换：

![进程状态的转换][pstatus]

 - 就绪状态 -> 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。
 - 运行状态 -> 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，
 在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。
 - 运行状态 -> 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如 I/O 操作的完成）时，
 它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。
 - 阻塞状态 -> 就绪状态：当进程等待的事件到来时，如 I/O 操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

## 1.4 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，
一般把进程控制用的程序段称为**原语**，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。

### 1.4.1 进程创建

允许一个进程创建另一个进程。此时创建者称为**父进程**，被创建的进程称为**子进程**。子进程可以继承父进程所拥有的资源。
当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。

在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。
操作系统创建一个新进程的过程如下（**创建原语**)：
1. 为新进程分配一个唯一的进程标识号，并申请一个空白的`PCB`(`PCB`是有限的)。若`PCB`申请失败则创建失败。
2. 为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在`PCB`中体现）。注意：这里如果资源不足（比如内存空间），
并不是创建失败，而是处于”等待状态“，或称为“阻塞状态”，等待的是内存这个资源。
3. 初始化`PCB`,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
4. 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。
 
### 1.4.2 进程终止

引起进程终止的事件主要有：
 - 正常结束，表示进程的任务已经完成和准备退出运行。
 - 异常结束，是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O 故障等。
 - 外界干预，是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。

操作系统终止进程的过程如下（**撤销原语**）：
1. 根据被终止进程的标识符，检索`PCB`，从中读出该进程的状态。
2. 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。
3. 若该进程还有子进程，则应将其所有子进程终止。
4. 将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。
5. 将该`PCB`从所在队列（链表）中删除。
 
### 1.4.3 进程阻塞和唤醒

正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，
则由系统自动执行**阻塞原语(Block)**，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，
也因此只有处于运行态的进程（获得 CPU），才可能将其转为阻塞状态。阻塞原语的执行过程是：
1. 找到将要被阻塞进程的标识号对应的`PCB`。
2. 若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。
3. 把该`PCB`插入到相应事件的等待队列中去。

当被阻塞进程所期待的事件出现时，如它所启动的 I/O 操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）
调用**唤醒原语(Wakeup)**，将等待该事件的进程唤醒。唤醒原语的执行过程是：
1. 在该事件的等待队列中找到相应进程的`PCB`。
2. 将其从等待队列中移出，并置其状态为就绪状态。
3. 把该`PCB`插入就绪队列中，等待调度程序调度。

需要注意的是，`Block`原语和`Wakeup`原语是一对作用刚好相反的原语，必须成对使用。`Block`原语是由被阻塞进程自我调用实现的，
而`Wakeup`原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的。

### 1.4.4 进程切换

对于通常的进程，其创建、撤销以及要求由系统设备完成的 I/O 操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。
进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。

进程切换的过程如下：
1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新`PCB`信息。
3. 把进程的`PCB`移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其`PCB`。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到核心态运行，
执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的 CPU 现场，无需改变当前进程的环境信息。
但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。

## 1.5 进程组织

进程是操作系统的资源分配和独立运行的基本单位。它一般由以下三个部分组成。

### 1.5.1 进程控制块（PCB）

进程创建时，操作系统就新建一个`PCB`结构，它之后就常驻内存，任一时刻可以存取, 在进程结束时删除。`PCB`是进程实体的一部分，
是进程存在的唯一标志。当创建一个进程时，系统为该进程建立一个`PCB`；当进程执行时，系统通过其`PCB`了解进程的现行状态信息，
以便对其进行控制和管理；当进程结束时，系统收回其`PCB`，该进程随之消亡。操作系统通过`PCB`表来管理和控制进程。

下表显示了`PCB`通常包含的内容：

| 进程描述信息 | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
| ----------- | ---------------- | ----------- | -------------- |
| 进程标识符(PID) | 进程当前状态 | 代码段指针 | 通用寄存器值 |
| 用户标识符(UID) | 进程优先级 | 数据段指针 | 地址寄存器值 |
| | 代码运行入口地址 | 堆栈段指针 | 控制寄存器值 |
| | 程序的外存地址 | 文件描述符 | 标志寄存器值 |
| | 进入内存时间 | 键盘 | 状态字 |
| | 处理机占用时间 | 鼠标 | |
| | 信号量使用 | | |

`PCB`主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下：
1. 进程描述信息
    - 进程标识符：标志各个进程，每个进程都有一个并且是唯一的标识号。
    - 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。
2. 进程控制和管理信息
    - 进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。
    - 进程优先级：描述进程抢占处理机的优先级，优先级高的进程可以优先获得处理机。
3. 资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况；所打开文件的列表和所使用的输入/输出设备信息。
4. 处理机相关信息，主要指处理机中各寄存器值，当进程被切换时，处理机状态信息都必须保存在相应的`PCB`中，以便在该进程重新执行时，
能再从断点继续执行。

在一个系统中，通常存在着许多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，
需要将各进程的`PCB`用适当的方法组织起来。目前，常用的组织方式有链接方式和索引方式两种。
链接方式将同一状态的`PCB`链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的`PCB`，
根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的`PCB`，
不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。

### 1.5.2 程序段

程序段就是能被进程调度程序调度到`CPU`执行的程序代码段。注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序。

### 1.5.3 数据段

一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。

## 1.6 进程通信

进程通信是指进程之间的信息交换。`PV`操作（P 操作：申请资源操作；V操作：释放资源操作）是低级通信方式，
髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。

### 1.6.1 共享存储

在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。
在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P 操作、V 操作），对共享空间的写/读进行控制。
共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。
操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。

需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，
而进程内的线程是自然共享进程空间的。

### 1.6.2 消息传递

在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，
则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。
 - 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。
 - 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，
 这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。
 
### 1.6.3 管道通信

管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，
又名`pipe`文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；
而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：
互斥、同步和确定对方的存在。

# 2. 线程

## 2.1 概念

在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。
任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，
使得各个进程之间内存地址相互隔离。

后来，随着计算机的发展，对 CPU 的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。
于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是**处理器调度和分派的基本单位**。
一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。
一个标准的线程由线程 ID，当前指令指针 PC，寄存器和堆栈组成。而进程由内存空间(代码，数据，进程空间，打开的文件)
和一个或多个线程组成。

引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，
提高操作系统的并发性能。

线程最直接的理解就是“轻量级进程”，它是一个基本的 CPU 执行单元，也是程序执行流的最小单元。线程是进程中的一个实体，
是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，
但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，
同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。
线程也有就绪、阻塞和运行三种基本状态。

引入线程后，进程的内涵发生了改变，**进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元**。

## 2.2 线程和进程的比较

1. 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，
进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，
如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。
2. 拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），
但线程可以访问其隶属进程的系统资源。
3. 并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，
提高了系统的吞吐量。
4. 系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，
因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，
涉及当前执行进程 CPU 环境的保存及新调度到进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。
5. 地址空间和其他资源（如打开的文件）：进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，
某进程内的线程对于其他进程不可见。
6. 通信方面：进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段
（如全局变量）来进行通信。

下图显示了线程和进程的关系：

![进程和线程的关系][rel]

## 2.3 线程的属性

在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是一个基本的可执行实体。
但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。线程的主要属性如下：
 - 线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，
 线程控制块记录了线程执行的寄存器和栈等现场状态。
 - 不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程。
 - 同一进程中的各个线程共享该进程所拥有的资源。
 - 线程是处理机的独立调度单位，多个线程是可以并发执行的。在单 CPU 的计算机系统中，各线程可交替地占用 CPU；
 在多CPU的计算机系统中，各线程可同时占用不同的 CPU，若各个 CPU 同时为一个进程内的各线程服务则可缩短进程的处理时间。
 - 一个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。
 
## 2.4 线程的实现方式

线程的实现可以分为两类：<strong>用户级线程(User-LevelThread, ULT)</strong>和<strong>内核级线程(Kemel-LevelThread, KLT)</strong>。
内核级线程又称为内核支持的线程。

在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。
通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。
图(a)说明了用户级线程的实现方式。

在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。
内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。图(b)说明了内核级线程的实现方式。

在一些系统中，使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。
一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。图(c)说明了用户级与内核级的组合实现方式。

![用户级和内核级线程][t-category]

## 2.5 多线程模型

有些系统同时支持用户线程和内核线程由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。

### 2.5.1 多对一模型

将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明）。
 - 优点：线程管理是在用户空间进行的，因而效率比较高。
 - 缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。

### 2.5.2 一对一模型
将每个用户级线程映射到一个内核级线程。
 - 优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。
 - 缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。

### 2.5.3 多对多模型
将 n 个用户级线程映射到 m 个内核级线程上，要求 m <= n。

特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，
又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，
可谓集两者之所长。


[pstatus]: ../../../res/img/process-thread-pstatus.png
[rel]: ../../../res/img/process-thread-rel.png
[t-category]: ../../../res/img/process-thread-t-category.jpg