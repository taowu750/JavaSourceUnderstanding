# 1. 简介

哈希（Hash）也称为散列，就是把任意长度的输入，通过**散列算法**，变换成固定长度的输出，这个输出值就是散列值。
哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，
它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做**散列函数**，存放记录的数组叫做**散列表**。

如果没有内存限制，我们可以直接将键作为（可能是一个超大的）数组的索引，那么所有查找操作只需要访问内存一次即可完成。
但这种理想情况不会经常出现，因为当键很多时需要的内存太大。另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，
这样就只需要很少的内存。而散列表则使用了适度的空间和时间并在这两个极端之间找到了一种平衡。事实上，我们不必重写代码，
只需要调整散列算法的参数就可以在空间和时间之间作出取舍。我们会使用概率论的经典结论来帮组我们选择适当的参数。

使用`hash`的查询算法分为两步：
1. 用Hash函数将被查找的键转化为数组的一个索引。理想情况下，不同的键都能转化为不同的索引值。当然，这只是理想情况，
所以我们需要面对两个或者多个键都会散列到相同的索引值的情况。
2. 处理碰撞冲突的过程

一个好的`hash`函数应满足下列三个条件：
 - 一致性 —— 等价的`key`必然产生相等的`hash code`
 - 高效性 —— 高效的计算
 - 均匀性 —— 均匀地散列所有的`key`
 
# 2. 常见的哈希算法

## 2.1 除法哈希法

基本公式：`hash(key) = key % M`。

在除法哈希法中，`M`通常为一个较大的素数。

### 2.1.1 为什么是素数？<sup id="a1">[\[1\]](#f1)</sup>

之所以使用素数，是因为素数在做取模运算时，余数的个数是最多的。使用素数可以让元素取模后的值，
更不容易发生冲撞。那么其中的原理是怎么样的呢？

首先我们需要了解合数和素数：合数即有两个以上的因数，素数（质数）即只有两个因数，分别为 1 和其本身。
如果对一个合数取模，那么对其某个因数取模，结果可能仍然一致。例如 10 对 8 取模，结果为 2，对 4 取模，结果也为 2。
而我们对一个素数取模，由于素数只有 1 和其本身两个素数，即不可能出现上述情形。

取余实际相当于一种映射。比如我们给定一个整数的集合![](http://latex.codecogs.com/gif.latex?A={a_0,a_1,a_2,...,a_i})，
我们要对该集合里面的所有元素对数字`j`取余，那么`A`中所有元素取余后的值的集合
![](http://latex.codecogs.com/gif.latex?A={0,1,2,...,j-1})，取余实际上就是将集合`A`映射到集合`B`，
![](http://latex.codecogs.com/gif.latex?A\stackrel{f(x)}{\longrightarrow}B)。我们来看几个例子

> 例 1

![例 1][e1]

> 例 2

![例 2][e2]

这两个例子差别在哪呢？后面这个例子虽然映射前集合`A`的元素数量仍然是`12`个，但是映射后的元素只出现了 0、2、4，
也就是说集合`B`中的元素，有即超过一半多的元素根本就没有用上！

> 例 3

![例 3][e3]

这里为了避免因模数改变过大而造成取余后的值分布范围增大，我们取了跟 8 最接近并且比它小的一个素数 7。可以看出，模数换成素数后，
原来的集合`A`并没有改变，但是最终映射的结果却 100% 的利用了新的余数空间（而新的余数空间和旧余数空间大小只相差 1）。
也就是说，使用素数作为模数，可以提高余数空间的利用率！当然，如果原集合中的元素属于均匀分布或者接近均匀分布的话
（元素间的值差均匀且较小），模数用素数和非素数的差距并不大（第一个例子）。

### 2.1.2 证明

![证明步骤 1][prove1]


PS：![](http://latex.codecogs.com/gif.latex?N^0})是自然数集合，![](http://latex.codecogs.com/gif.latex?N^+})是正整数集合。

> 特殊情况

1. 当`p`是`q`的倍数时，`k = q, n = 1, d = m`，而余数`r = 0`。所以为`q`的倍数的数`hash`之后会发生冲突。
2. 当`q`是`p`的倍数时，`k = p, m = 1, d = 0`，而余数`r = p`。

> 当 q 为合数

当模数`q`为合数时，若此时集合中的元素`p`为素数，则有`k = 1`，也就是说此时余数可以遍取余数空间的所有值：`r = 0, 1, 2...`。
当模数`q`为合数时，且集合中的元素`p`也为合数，则有`k = 1, 2, 3,...`。也就是说余数有可能只能取余数空间中的部分值：
 - `r = 0, 2, 4,...  k = 2`
 - `r = 0, 3, 6,...  k = 3`
 - ...

总结上述两点来说，当模数`q`取合数时，如果原集合`A`中的合数较多时，会导致大量的余数空间被浪费，
这种情况的另一个不利影响是加剧了余数之间的碰撞（重叠）。

> 当 q 为素数

当模数`q`为素数时，不管原集合`A`中的元素`p`取什么值，只要`p`不是`q`的倍数，则必有`k=1`，
此时余数可以遍取余数空间的所有值：`r = 0, 1, 2,...`。也就是说，只要我们的模数为素数，不管原集合`A`中的素数和非素数的组成情况如何，
都能充分利用余数空间。这就解释了为什么我们做模运算的时候，模数要选择素数。

### 2.1.3 为什么要用大素数？

这个原因就比较简单了，使用大的素数，可以尽量减小余数之间的碰撞。仍以前面的例 3 来说，原集合大小为 12，余数空间大小为 7，
也就是说原集合中有`12 - 7 = 5`个元素因为余数空间的限制，跟其他元素的余数发生了碰撞（重叠）。

## 2.2 乘法哈希法

公式：`hash(key) = (A * key % 2^w)rsh(w - r)`。
其中：
 - `w`为计算机字长大小，例如 32 位、64 位。
 - `A`是一个等长于计算机字长的奇数，满足`2^(w-1) < A < 2^w`。
 - `rsh`是右移操作
 - `r`是一个与哈希表大小有关的常数，设哈希表长度为`m`，`r = ⌈log2(m)⌉`。一般令`m`为 2 的幂，此时`m = 2^r`。

`A * key`是一个`2w`字长的数，对`2^w`取余，结果是低`w`位。接着向右偏移`w - r`位，保留上一结果中`w`位的高`r`位。
之所以令`2^(w-1) < A < 2^w`，道理和 2.1 节中使用大素数一样。一般的实现中我们不用对`2^w`取余，高`w`位会因为溢出截断。

### 2.2.1 Knuth 乘法散列法

在弄懂上面算法的原理之前，我们先来看看 Knuth 乘法散列法的数学公式：`hash(key) = ⌊m * (key * A % 1)⌋`。
其中：
 - `m`是散列表长度，一般取 2 的幂`2^r`。
 - `A`是一个常数，`0 < A < 1`。令`A = s / 2^w`，其中`0 < s < 2^w`，`w`是计算机字长。
 - 对 1 取余是取出`k * A`的小数部分。

分析如下：
1. `key * A`等于`key * s / 2^w`，而`s = A * 2^w`。
2. 乘积`key * s`结果可视为一个`2w`位的值`r1 * 2^w + r0`，其中`r1`是乘积高`w`位字，`r0`是乘积低`w`位字。
3. 除以`2^w`，得到`r1.r0`，`r0`被移到了小数部分。
4. 对 1 取余，得到小数部分`0.r0`。
5. 最后乘以`m`向下取整，得到`r0`的高`r`位。

可以看到，此方法和 2.2 乘法哈希法原理一致，可以将 2.2 乘法哈希法看作是 Knuth 乘法哈希法在程序中的实现。

> 例子

我们设`m = 2 ^ 3 = 8`，`r = 3`。取字长为 8 位，即`w = 8`。设`A = 0.10110010`，`key = 11010110`，
`A * key = 10010100.11001100`，取小数部分高`r`位得`110`，所以结果就是`hash(key) = 110 = 6`。

为了理解这个过程，我们画一个车轮，代表哈希表。因为`m = 8`，将其 8 等分。如下图所示：

![哈希环][circle]

`A`乘以`m`为`101.1001`，约为 5.5。所以：
 - 当`key = 1`时，`A * key = A * 1 = 5.5`，从下标 0 的位置开始顺时针转到 5.5 的位置。
 - 当`key = 2`时，`A * key = A * 1 = 11`，大约绕到 11 % 8，略微超过 3 的位置。
 - 当`key = 3`时，`A * key = A * 3 = 16.5`，大约绕到 16.5 % 8，即约 0.5 的位置。

每次多加一个`A`，就会多家一段`A`的弧长。如果`A`为奇数，那么哈希的过程就类似于把键放入不同的槽中。如果`key`很大，
就会绕几圈。

### 2.2.2 斐波那契（Fibonacci）哈希法

也就是当“乘法哈希法”的`A = 2^W / φ, 1 / φ ≈ (√5-1)/2 = 0.618 033 988`时的情况，而`(√5-1)/2`被称为**黄金分割点**。
此时，散列的效果最均匀。对于 32 位，`A`的值为`2654435769`。

为什么选择黄金分割点效果最好呢？这与使用乘法对连续键进行散列时发生的情况有关。如图“斐波那契散列”所示，
连续的`key`分布得很好。实际上，当我们使用`A = 2^W / φ`对连续键进行哈希处理时，
每个后续键的哈希值都位于两个已经计算的最宽间距的哈希值之间。此外，黄金分割率`φ`的一个特性是，
每个后续哈希值都会根据黄金分割率划分其落入的间隔。

![斐波那契散列][gold]

# 3. Java 中的哈希

## 3.1 Java 中的哈希算法

`Java`中的`hashCode`函数被建议返回素数，这是因为在`Java`的`HashMap`、`HashSet`等哈希表数据结构中，
哈希表的大小（bucket 的数量）是 2 的幂。根据 2.1 节所述，此时`q`是个合数，那么我们需要让`p`变为素数以充分利用余数空间，
减少冲突。为什么`Java`中的哈希表大小是 2 的幂呢？这是因为当`n`是 2 的幂时，第一是可以使用`p & (n - 1)`代替`p % n`，
达到更高的计算效率；第二是 2 的幂扩容计算很简单。
 
下面是原理：
> 首先需要知道：
> - 二进制数乘以 2^n，相当于左移 n 位；
> - 二进制数除以 2^n，相当于右移 n 位；
> - 任何二进制数和 1 的 & 操作，还是原来的二进制数
> 
> 设 xx...xx 是一个 n 位二进制数（x 为 1 或 0），xx...xx = x*2^(n-1) + x*2^(n-2) +...+ x*2^1 + x*2^0。
> 让它除以 2^m，可得：  
> xx...xx / 2^m  
> = (x*2^(n-1) + x*2^(n-2) +...+ x*2^1 + x*2^0) / 2^m  
> = x*2^(n-1-m) + x*2^(n-1-m) +... + x*2^(m-m) + x*2^(m-1-m) + ... + x*2^(0-m)
>
> 其中 x*2^(m-m) = x*2^0，这就是所得二进制数的最低位。而其后面的那些项 x*2^(m-1-m) + ... + x*2^(0-m) 就是余数。
> 这里相当于把 xx...xx 右移了 m 位，而移出去的那 m 位，就是余数（因为前面的都可以整除，后面的是不可以整除的，就是余数）。
>
> 我们知道：二进制的 2^m-1，总共有 m+1 位， 除了最高位 m+1 位为 0，其余 m 位都为 1。那么：
> xx...xx & (2^m -1) 相当于取出了 xx...xx 的低 m 位二进制数，也就是上面所说的右移出去的那 m 位数，也就是余数。

## 3.2 Java 中的哈希函数<sup id="a2">[\[2\]](#f2)</sup>

`Java`中哈希函数的结果等价于下面的等式：
> s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]

其中`n`是因子个数，`s[i]`是第`i`个参与散列计算的因子。可以看到，它们都乘以了**31**这个素数。
 - 上面`hash`的计算表达式里相当于每项都有了素数，那么`hash % n`时也就近似相当于素数对`n`取模，
这个时候余数也就会尽可能的多。
 - 通过相乘，位将向左移动。这将使用更多的哈希码可用空间，从而减少冲突。
 - 不使用 2 的幂移位，最右边的低位也会被填充（而不是变成 0），并与进入哈希的下一个数据混合。

既然素数越大越好，素数又那么多，为什么要选择`31`？之所以选择`31`：
1. 计算机计算`31`比较快（`m * 31`可以优化为`(m << 5) - m`）
2. 大多数情况下我们都是采用`String`作为`key`，而这又是英语国家写出来的语言，曾有人对超过 5W 个英文单词做了测试,
在常量取`31`情况下, 碰撞的次数都不超过 7 次。


[e1]: ../../../res/img/hash-e1.png
[e2]: ../../../res/img/hash-e2.png
[e3]: ../../../res/img/hash-e3.PNG
[prove1]: ../../../res/img/hash-prove1.png
[circle]: ../../../res/img/hash-circle.png
[gold]: ../../../res/img/hash-gold.png

<b id="f1">\[1\]</b> 参考 https://flat2010.github.io/2018/04/19/%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%AD%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8%E7%B4%A0%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%A8%A1/。 [↩](#a1)  
<b id="f2">\[2\]</b> 参考 https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier。 [↩](#a2)