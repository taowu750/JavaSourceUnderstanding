# 1. 浮点数的定义

小数点在数制中代表一种**对齐方式**，比如说你要比较`1000`和`200`哪个比较大你应该怎么做呢？你必须把他们右对齐：
```
1000
 200
```
然后发现`1`比`0`（前面补零）大，所以`1000`比较大。那么如果是比较`1000`和`200.01`呢？这时候就不是右对齐了，而是对应位对齐，
也就是小数点对齐：
```
1000
 200.01
```

小数点位置在进制表示中是至关重要的，位置差一位整体就要差进制倍（十进制就是十倍）。在计算机中也是这样，虽然计算机使用二进制，
但在处理非整数时，也需要考虑小数点位置的问题，无法对齐小数点就无法做加法、减法比较这样的操作。我们说小数点位置，
永远是说相对于我们存储的数位来说的，比如说我们存储了`01001001`，然后小数点在第三位之后，也就是`010.01001`了。

在计算机中处理小数点位置有**浮点和定点**两种，定点就是小数点永远在固定的位置上，比如说我们约定一种 32 位无符号定点数，
它的小数点永远在第 5 位后面，这样最大能表示的数就是`11111.111111111111111111111111111`，它是32 - 2<sup>-27</sup>，
最小非零数是 2<sup>-27</sup>。定点数是提前对齐好的小数，整数是一种特殊情况，小数点永远在最后一位之后。定点数的优点是很简单，
大部分运算实现起来和整数一样或者略有变化，但是缺点则是表示范围，比如我们刚才的例子中，最大只能表示 32；而且在表示很小的数的时候，
大部分位都是 0，精度很差，不能充分运用存储单元。浮点数就是设计来克服这个缺点的，它相当于一个定点数加上一个**阶码**，
阶码表示将这个定点数的小数点移动若干位。由于可以用阶码移动小数点，因此称为浮点数。

# 2. 十进制二进制小数相互转换

## 2.1 十进制转二进制

把十进制小数转换成二进制，操作如下
1. 将小数划分成整数+小数两部分
2. 整数部分转换。转换采用**除2取余法**：除以 2，取出余数，商继续除以 2，直到得到 0 为止，将取出的余数逆序。
3. 小数部分转换。转换采用**乘2取整法**：乘以 2，然后取出整数部分，将剩下的小数部分继续乘以 2，然后再取整数部分，
一直取到小数部分为零为止。如果永远不为零，则按要求保留足够位数的小数，最后一位做 0 舍 1 入。将取出的整数顺序排列。

例如`22.8125`。整数部分：
```
22 / 2           商11 余 0
11 / 2           商5  余 1
5  / 2           商2  余 1
2  / 2           商1  余 0
1  / 2           商0  余 1
```
得到`22`的二进制是：`10110`

小数部分：
```
0.8125x2 = 1.625        取整1            小数部分是0.625
0.625x2 = 1.25          取整1            小数部分是0.25
0.25x2 = 0.5            取整0            小数部分是0.5
0.5x2 = 1.0             取整1            小数部分是0
```
得到`0.8125`的二进制是：`0.1101`

结果：十进制`22.8125`等于二进制`10110.1101`。

## 2.2 二进制转十进制

二进制小数转换成十进制，就是每一位乘以与该位对应的 2 的幂。例如
10110.1101 = 2<sup>4</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>-1</sup> + 2<sup>-2</sup> + 2<sup>-4</sup> = 22.8125

# 3. 浮点数的存储格式<sup id="a1">[\[1\]](#f1)</sup>

浮点数在计算机中的存储方式遵循`IEEE-754`浮点数的计数标准，它规定了四种浮点数格式：
 - 单精度（32 位）
 - 双精度（64 位）
 - 延伸单精度（43 位以上，很少使用）
 - 延伸双精度（79 位以上，通常以 80 位实现）

二进制浮点数由三部分组成：
 - 符号位（sign），0 表示正数，1 表示负数
 - 阶码（exponent），规定为实际数值加上一个偏移值。偏移值为 2<sup>n-1</sup> - 1，其中 n 为存储指数的比特位长度
 - 尾数（fraction），用于存储“有效数字”的小数部分，使用**原码**表示。
 
![float 格式][format]

采用**尾数+阶码**的编码方式，在我们学过的数学知识中，就是类似于科学计数法。即**有效数字+指数位**。
例如 5.75 = 101.11<sub>2</sub> = 1.0111<sub>2</sub> × 2<sup>2</sup>；
0.1875 = 0.0011<sub>2</sub> = 1.1<sub>2</sub> × 2<sup>-3</sup>。浮点数的取值范围主要看指数部分，而精度(有效尾数)看尾数部分。

所以，只要给出：符号、尾数、阶码这三种信息，就可以正确的表示一个浮点数。在`Java`中，
浮点数的数据类型最常用的就是`float`、`double`，它们在计算机中的存储结构如下图：

![Java float][float]

![Java double][double]

# 4. 举例说明

下面将着重分析 32 位单精度浮点数，如无特殊说明，均针对单精度浮点数。

单精度浮点数，长度为 32 位：
1. 最高 1 位为符号位
2. 接下来是 8 位阶码，偏移值为 2<sup>8-1</sup> - 1 = 127
3. 最后 23 位是尾数

## 4.1 正数实例

### 4.1.1 将十进制数转换为浮点数

22.8125 = 10110.1101<sub>2</sub> = 1.01101101<sub>2</sub> × 2<sup>4</sup>

1. `22.8125`为正数，所有符号位为 0。
2. 指数为 4，因此阶码为 4 + 127 = 131 = 10000011<sub>2</sub>
3. 由于尾数只存储有效数字的小数部分，所以尾数为`01101101`。最高位 1 规定不显示存储，以隐含方式存在，
计算或恢复数值的时候再把这个 1 补上。
4. 最终得到的 32 位浮点数表示为（分段方便阅读）：`0-10000011-01101101000000000000000`

可以在[FloatingNumberTest.java][test]中查看`Java`中的转换结果。

### 4.1.2 将浮点数恢复为十进制数

`0-10000011-01101101000000000000000`

1. 符号位为 0，说明是正数
2. 阶码为`10000011 = 131`，因此实际值是`133 - 127 = 4`
3. 尾数 = 小数部分`0.01101101000000000000000` + 隐含值`1` = `1.01101101000000000000000`
4. 因此，该浮点数所表示的实际数值为 1.01101101<sub>2</sub> × 2<sup>4</sup> = 10110.1101<sub>2</sub> = 22.8125

## 4.2 负数实例

-16 = 10010000<sub>2</sub> = -1.0 × 2<sup>4</sup>（这里用原码表示二进制）

1. 符号位为 1
2. 阶码为 4 + 127 = 131 = 10000011<sub>2</sub>
3. 尾数为 0
4. 因此 -16 的单精度浮点数表示为`1-10000011-00000000000000000000000`

## 4.3 舍入实例

有些浮点数无法被精确表示，比如 0.4：

0.4 = 0.01100110011001100110011001...<sub>2</sub> = 1.100110011001100110011001... × 2<sup>-2</sup>

1. 符号位为 1
2. 阶码为 -2 + 127 = 125 = 01111101<sub>2</sub>
3. 尾数为`10011001100110011001100-1`，由于只有 23 位，最后一个 1 被舍弃，按照浮点数舍入规则（参见 8.4），最终得到
`10011001100110011001101`
4. 因此`0.4`的单精度浮点数表示为`0-01111101-10011001100110011001101`

可以在[FloatingNumberTest.java][test]中查看`Java`中的转换结果。

## 4.4 浮点数表示步骤

1. 将十进制数值转化为二进制
2. 将二进制数值表示为科学计数法。其中二进制用原码表示。
3. 确定符号位，正数为 0，负数为 1
4. 计算阶码：将指数值加上偏移值（单精度为 127），再转换为 8 位二进制
5. 计算尾数：忽略有效数字整数部分 1（小数点左边的 1），将有效数字小数部分作为尾数，如果尾数不足 23 位则右边用 0 填充至 23 位。
视情况还需做舍入操作。

上面说的单精度浮点数二进制表示法可能不太严谨，但有时便于理解记忆更重要。[binarycovert][convert]是一个浮点数二进制转换网站，
可以在这里做转换测试。

# 5. 浮点数的表示形式

前面对于浮点数的介绍，其实指的是浮点数的**规格化表示形式**。规格化形式，是浮点数的主要表示形式，日常绝大多数数值都可以用它来表示。
然而，还是有一些特殊数值是无法用规格化形式表示的，例如 0、非常接近 0 的数值、无穷。

## 5.1 浮点数的 5 种表示形式

| 浮点数形式 | 阶码 | 尾数 | 描述 |
| --------- | ---- | ---- | --- |
| 0 | 0 | 0 | 阶码是 0，尾数的小数部分是 0，这个数是 ±0（取决于符号位） |
| 非规格化 | 0 | 非 0 | 阶码是 0，尾数的小数部分是非 0，有效数字的整数部分为固定数值 0。它表示非常接近 0 的数值。（指数偏移值为 2<sup>n-1</sup> - 2） |
| 规格化 | \[1, 2<sup>n</sup> - 2\] | 任意 | 阶码位不包括全 0 和 全 1，尾数的小数部分为任意值。有效数字的整数部分为固定值 1，使用隐含方式表示。因此尾数只存储有效数字的小数部分。（指数偏移值为 2<sup>n-1</sup> - 1） |
| Infinite | 2<sup>n</sup> - 1 | 0 | 阶码是 2<sup>n</sup> - 1（阶码位全是 1），尾数的小数部分是 0，这个数是 ±∞（正负取决于符号）|
| NaN | 2<sup>n</sup> - 1 | 非 0 | 阶码是 2<sup>n</sup> - 1，尾数的小数部分是非 0，这个数表示为不是一个数 |

其中，n 为存储指数的比特位长度，对于单精度浮点数为 8。

## 5.2 NaN

`NaN`（Not a Number，非数）是计算机科学中数值数据类型的一个值，表示未定义或不可表示的值，常在浮点数运算中使用。
首次引入`NaN`的是 1985 年的`IEEE-754`浮点数标准。

以下操作会产生`NaN`：
 - 操作数中至少有一个是`NaN`的运算
 - 未定义操作
    - 下列除法运算：0/0、∞/∞、∞/−∞、−∞/∞、−∞/−∞
    - 下列乘法运算：0×∞、0×-∞
    - 下列加法运算：∞ + (−∞)、(−∞) + ∞
    - 下列减法运算：∞ - ∞、(−∞) - (−∞)
 - 产生复数结果的实数运算。例如：
    - 对负数进行开方运算
    - 对负数进行对数运算
    - 对比-1小或比+1大的数进行反正弦或反余弦运算

`NaN`也是唯一不等于自身的数。除了前面的情况，`NaN`和任何数比较都会得到`false`。

## 5.3 非规格化形式

一般当某个数字非常接近 0 的时候，才需要使用非规格化形式来表示。`IEEE 754`标准规定，
非规格化形式的浮点数的指数偏移值比规格化形式的指数偏移值小 1，也就是 2<sup>n-1</sup> - 2。
对于单精度浮点数，偏移值为 126。因此，实际指数为固定数值 -126（阶码 0 减去偏移值 126）。

非规格化形式解决了绝对值意义下最小规格数与 0 的距离，避免了<strong>突然式下溢出（abrupt underflow）</strong>。
突然式下溢出后面会讲到。

## 5.4 单精度浮点数的各种极值情况

说明：为了方便叙述，以下最大值与最小值指绝对值大小，实际要结合符号来看。

| 浮点数形式 | 正负号 | 有效数字 | 实际指数 | 表示数值 |
| --------- | ------ | ------- | ------- | -------- |
| -Infinite | 1 | 1.0 | 128 | -∞ |
| 规格化最大值 | 1 | 2 - 2<sup>-23</sup> | 127 | -(2 - 2<sup>-23</sup>) × 2<sup>127</sup> = -3.4e+38 |
| 规格化最小值 | 1 | 1.0 | -126 | -2<sup>-126</sup> = -1.18e-38（-1.17549435e-38） |
| 非规格化最大值 | 1 | 1 - 2<sup>-23</sup> | -126 | -(1 - 2<sup>-23</sup>) × 2<sup>-126</sup> = -1.18e-38（-1.17549421e-38） |
| 非规格化最小值 | 1 | 2<sup>-23</sup> | -126 | -2<sup>-23</sup> × 2<sup>-126</sup> = -1.4e-45 |
| 负 0 | 1 | 小数部分是 0 | -127 | -0.0 |
| 正 0 | 0 | 小数部分是 0 | -127 | +0.0 |
| 非规格化最小值 | 0 | 2<sup>-23</sup> | -126 | 2<sup>-23</sup> × 2<sup>-126</sup> = 1.4e-45 |
| 非规格化最大值 | 0 | 1 - 2<sup>-23</sup> | -126 | (1 - 2<sup>-23</sup>) × 2<sup>-126</sup> = 1.18e-38（1.17549421e-38） |
| 规格化最小值 | 0 | 1.0 | -126 | 2<sup>-126</sup> = 1.18e-38（1.17549435e-38） |
| 规格化最大值 | 0 | 2 - 2<sup>-23</sup> | 127 | (2 - 2<sup>-23</sup>) × 2<sup>127</sup> = 3.4e+38 |
| +Infinite | 0 | 小数部分是 0 | 128 | ＋∞ |
| NaN | 0 或 1 | 小数部分非 0 | 128 | NaN |

关于有效数字中的 2<sup>-23</sup> 怎么来的，举个例子就明白了：  
规格化最大值的有效数字 = 1.11...1（小数点后 23 个 1）= 2 - 0.00...01（小数点后 22 个 0）= 2 - 2<sup>-23</sup>。

可以在[FloatingNumberTest.java][test]中查看这些特殊值在`Java`中的二进制表示。

## 5.5 小结

 - 上面的表格从上到下，从负无穷到正无穷（`NaN`除外），**浮点数集合的所有元素都是有序的**。
 - 规范化形式包含两个区间：`[-3.4e+38, -1.18e-38]`, `[1.18e-38, 3.4e+38]`。它无法表达相当接近 0 的区间：`[0, ±1.18e-38)`。
 - 非规范化形式也包含两个区间：`[-1.18e-38, -1.4e-45]`, `[1.4e-45, 1.18e-38]`。相比于规格化形式，它可以表示更接近于 0 的数值。
 - 非规格化最大值，与规格化最小值形成了平滑过渡（相差 2<sup>-149</sup>）。
 - 浮点数区分正负 0，但两者是相等的。在实际操作上存在一些区别，例如 1.0 / +0.0 = +∞，1.0 / -0.0 = -∞

在只有规格化形式的情况下，正数第 1 小、第 2 小、第 3 小和第 4 小分别是 2<sup>-126</sup>、
(1 + 2<sup>-23</sup>) × 2<sup>-126</sup>、(1 + 2 * 2<sup>-23</sup>) × 2<sup>-126</sup>、
(1 + 3 * 3<sup>-23</sup>) × 2<sup>-126</sup>，两两之间的差距都是 2<sup>-149</sup>。

然而，规格化最小值与 0 的间距是 2<sup>-126</sup>，2<sup>-126</sup> 比 2<sup>-149</sup> 大了 2<sup>23</sup> 倍。
原来靠近 0 的方向，值都是逐渐减小的，但到了最小值 2<sup>-126</sup>，下一个数突然就变成 0 了，
这种情况被称为<strong>突然式下溢（abrupt underflow）</strong>。

为了解决突然式下溢出问题，IEEE 采用了 Intel 力荐的<strong>渐进式下溢出（gradual underflow）</strong>，
在浮点数标准中对应的实现就是非规格化的表现形式。非规格化形式的最小值与 0 之间的距离为 2<sup>-149</sup>，
刚好与规格化数值之间的最小间距相等，解决了突然下溢至 0 的问题。

# 6. Why Why Why

重要的事情说三遍，先来回答几个问题。

## 6.1 指数为什么要加上偏移值？

指数存储的时候需要加上偏移值，但恢复的时候还要再减回来，直接存储指数不是更加简单明了吗？答案是肯定的，但凡事都有两面性，
我们需要来看看为什么这样设计。

如果不加上偏移，一个数转化为浮点数之后，符号位、阶码都是带符号的，这会复杂判断逻辑。在使用了偏移值之后，无论指数部分是正是负，
都可以转为非负数。将真值映射到正数域的数值（真值在数轴上正向偏移一个偏移量），称为**移码**。使用移码比较大小会很简单。

## 6.2 为什么偏移值是 2<sup>n-1</sup> - 1 而不是 2<sup>n-1</sup>？

8 位二进制有符号数的取值范围是`[-128, 127]`，8 位二进制无符号数的取值范围是`[0, 255]`。要是指数非负，
`[-128, 127]`需要加上偏移值 128，得到阶码是`[0, 255]`。`IEEE-754`规定阶码 0 和 255 表示特殊值。那么，
阶码实际能表示的范围是`[1, 254]`。如果偏移值仍为 128，那么指数范围变为 `[-127, 126]`。

为了让浮点数能够表示更大的取值范围，将指数范围加上 1 得到`[-126, 127]`，对应偏移值减去 1 得到 127。显然，最大指数值增大了，
可以表示更大的数值；但同时，最小指数值也变大了，原来可以表示的最小数值现在表示不了了。现在，规格化形式能够表示更大的数值，
而更小的数值可以由非规格化形式来表示。

在数轴上表示浮点数如下：

![浮点数范围][range]

无穷大在两头，0 与无穷大之间的大部分是规格化数，只有非常接近 0 的部分是非规格化数。而且，越是靠近 0 的地方，数与数的间隔越小。
相反，越是往无穷大的地方，数与数的间隔越大。

阶码的规定如下：
 - 阶码的范围是：1 到 2<sup>n</sup> - 2，对于单精度浮点数是`[1, 254]`。
 - 偏移值是：2<sup>n-1</sup> - 1，对于单精度浮点数是 127。
 - 单精度的实际指数范围是`[-126, 127]`。

## 6.3 为什么隐含最高位 1？

由于使用科学计数法表示二进制数值时，最高位固定为 1。因此，通过省略最高位，浮点数的尾数可以增加 1 位来更精确地表示数值
（23 位尾数，能表示 24 位二进制数值）。

# 7. 浮点数的舍入模式

浮点数表示的数据范围比定点数更广泛，但它并不能精确的表示在最大数和最小数之间的所有实数，例如无理数 √3，有理数 0.1。
`IEEE 754`定义了四种<strong>舍入模式（Rounding Mode）</strong>：
 - 偶数舍入：向最接近的可表示的值舍入，当有两个最接近的可表示的值时首选“偶数”值。
 Reiser&Knuth<sup id="a2">[\[2\]](#f2)</sup><sup id="a3">[\[3\]](#f3)</sup>解释了为什么首选“偶数”而不是“奇数”。
 - 向下舍入：向正无穷大舍入，也就是向比它大的方向靠近
 - 向下舍入：向负无穷大舍入，也就是向比它小的方向靠近
 - 向零舍入
 
除了向偶数舍入以外，其它三种方式都会有明确的边界。这三种方式舍入后的值`x'`与舍入之前的值`x`会有一个明确的大小关系，
比如对于向上舍入来说，则一定有`x <= x'`。对于向零舍入来说，则一定有`|x| >= |x'|`。

对于向偶数舍入来讲，它最大的作用是在统计时使用。向偶数舍入可以让我们在统计时，将舍入产生的误差平均，从而尽可能的抵消。
其原因我们可以这样来理解：在进行舍入的时候，最后一位数字从 1 到 9，舍去的有 1、2、3、4；它正好可以和进位的 9、8、7、6 相对应，
而 5 却被单独留下。如果我们采用四舍五入每次都将 5 进位的话，在进行一些大量数据的统计时，就会累积比较大的偏差。
而如果采用向偶数舍入的策略，在大多数情况下，5 舍去还是进位概率是差不多的，统计时产生的偏差也就相应要小一些。
其它三种方式在这方面都是有一定缺陷的，向上和向下舍入很明显，会造成值的偏大或偏小。而对于向零舍入来讲，
如果全是正数的时候则会造成结果偏小，全是负数的时候则会造成结果偏大。

在二进制中，偶数我们认为是末尾为 0 的数。`0.xxx01`和`0.xxx10`的中间值是`0.xxx011`；`0.xxx10`和`0.xxx11`的中间值是`0.xxx101`；
`0.xxx01..11`和`0.xxx10..00`的中间值是`0.xxx01..111`，它们的中间值都会舍入到末尾为 0 的偶数。
比如对于`10.10011`这个值来讲，当舍入到个位数时，会采取向上舍入（因为`10.10011`比起`10`更接近`11`），
因此此时的值为`11`。当舍入到小数点后 1 位时，会采取向下舍入（因为`10.10011`比起`11.0`更接近`10.1`），因此此时的值为10.1。
当舍入到小数点后4位时，由于此时为10.10011舍入值的中间值（`10.10011`是`10.1001`和`10.1010`的中间值），因此采用向偶数舍入，
此时舍入后的值为`10.1010`。

可以在[FloatingNumberTest.java][test]中查看不同舍入在`Java`中的结果。

# 8. 浮点数加减运算

本节中令浮点数尾数的小数点均固定在第一位数值位前（即有效数字只有小数部分）。浮点数尾数的加减运算规则和定点数完全相同。
但由于其阶码的大小直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不同时，两尾数小数点实际位置不一样，
尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按照以下几步进行：<strong>对阶、尾数求和、规格化、舍入、溢出判断</strong>。

## 8.1 对阶

对阶的目的是使操作数的小数点对齐，即两数阶码相同。为此，首先要求出**阶差**，再按照**小阶向大阶看齐**的原则，使阶小的尾数右移，
每右移一位，阶码加 1，直到两者阶码相同为止。右移的次数正好等于阶差。之所以按照此原则，是因为：
 - 如果把阶码大的向阶码小的看齐，就要把阶码大的数的尾数部分左移，阶码减小。这个操作有可能在移位过程中把尾数的高位部分移掉，
 这样就引发了数据的错误，所以，尾数左移在计算机运算中不可取。
 - 如果把阶码小的向阶码大的看齐，在移位过程中如果发生数据丢失，也是最右边的数据位发生丢失，最右边的数据位丢失，
 只会影响数据的精度，不会影响数据的大小。

需要注意的是，小阶向大阶看齐，也就是小数要向大数看齐，这可能会导致小数尾数部分变成 0，出现**大数吃小数**的情况。

举个例子，有两浮点数 X = 0.1101<sub>2</sub> * 2<sup>1</sup>，Y = -0.1010<sub>2</sub> * 2<sup>3</sup>，求 X + Y。

1. 首先我们写出 X、Y 的补码表示：\[X\]<sub>补</sub> = 00,01;00.1101、\[Y\]<sub>补</sub> = 00,11;11.0110。
2. ";"前面的是阶码，后面是尾数补码表示。补码使用双符号位形式，"00"代表正数，"11"代表负数。阶码符号位用","分开。
双符号位是为了能快速检测出运算结果是否有溢出。符号位为"01"的时候称为"上溢",即最高真值位相加后有进 1；
为"10"时，称为"下溢"，即最高真值位相减后有借 1。
3. 在进行加法前，先对阶，故先求阶差：\[E<sub>X</sub>\]<sub>补</sub> + \[-E<sub>Y</sub>\]<sub>补</sub> = 00,01 + 11,01 = 11,10。
求得 △E = 11,10 = -2，这表示 X 的阶码比 Y 的阶码小。
4. 按照小阶向大阶看齐原则，将 X 的尾数右移两位，其阶码加 2：\[X\]<sub>补</sub> = 00,11;00.0011。至此，对阶完成。

## 8.2 尾数求和

尾数求和是补码加法，则有：\[M<sub>X</sub> + M<sub>Y</sub>\]<sub>补</sub> = 00.0011 + 11.0110 = 11.1001。
即 \[X + Y\]<sub>补</sub> = 00,11;11.1001。

## 8.3 规格化

规格化处理主要是针对浮点数的尾数部分，规格化的尾数格式要求如下:
 - 尾数采用原码表示形式时：正数的规格化格式为：00.1XXX，负数的规格化形式为11.1XXX。即第一数位需要为 1。
 - 尾数采用补码表示形式时，正数的规格化格式为：00.1XXX，负数的规格化形式为：11.0XXX。即尾数第一位和符号位不能相同。
 
之所以要这样，是因为`IEEE-754`规定了规格化形式最高位 1 以隐含方式存在，这就需要原码第一数位为 1。当尾数求和(差)不满足规格化形式时，
则需要进行规格化，规格化又分为左规和右规。

 - 左规：当尾数出现 00.0XXX 或者 11.1XXX 时，需左规。左规尾数左移一位，阶码减 1，直到符合规格化形式为止。例如前例
\[X + Y\]<sub>补</sub> = 00,11;11.1001 尾数第一位和符号位相同，需左规，得 \[X + Y\]<sub>补</sub> = 00,10;11.0010。
 - 右规：当尾数出现 01.XXX 或 10.XXX 时，表示尾数溢出，这在定点数加减法中是不允许的，但在浮点运算中这不算溢出，可以通过右规处理。
右规时尾数右移一位，阶码加 1。

## 8.4 舍入

在对阶和右规的过程中，可能会将尾数的低位丢失，引起误差影响精度。为此，引入舍入来提高尾数的精度。
常用的舍入方式有三种：<strong>截断法、零舍一入法和恒置一法</strong>。

 - 截断法：将移出的数据一律舍去。该方法简单，很常用。但是影响精度。
 - 零舍一入法：此方法类似于 10 进制的四舍五入法，即在尾数右移时，被移去的数位为 0，则舍去；为 1，则在尾数末尾加 1。
 这样做可能使尾数又溢出，此时需要再做一次右规。
 - 恒置一法：尾数右移时，不论丢掉的最高位数值是 1 还是 0，都使右移后的尾数末尾置一。这种方法同样有使尾数变大和变小两种可能。

## 8.5 溢出判断

在浮点数规格化中已指出，当尾数出现 01.XXX 或 10.XXX 时，并不表示溢出，只有将此数右移后，再根据阶码判断浮点运算是否溢出。
若机器数为补码，尾数为规格化形式，并假设阶码数值部分有 7 位，尾数数值部分有 n 位，则有：
 - 最小负数：补码表示为 00,1111111;11.000...0，真值为 -2<sup>127</sup>
 - 最大负数：补码表示为 11,0000000;11.011...1，真值为 (-1/2 - 2<sup>-n</sup>) * 2<sup>-128</sup>
 - 最小正数：补码表示为 11,0000000;00.100...0，真值为 1/2 * 2<sup>-128</sup>
 - 最大正数：补码表示为 00,1111111;00.111...1，真值为 (1 - 2<sup>-n</sup>) * 2<sup>127</sup>

处于最大负数和最小正数之间的数，阶码小于 -128，这种情况称为浮点数的下溢。下溢时，浮点数趋近于 0，故机器不做溢出处理，仅把它作为 0。
小于最小负数和大于最大正数的数，阶码大于 127，这种情况称为浮点数的上溢。此时浮点数真正溢出，机器需停止运算，做溢出中断处理
（可能转为`+∞`或`-∞`）。一般说浮点数溢出，均指上溢。

可以看到，浮点数的溢出与否可由阶码的符号位决定。即 \[E\]<sub>补</sub> = 01,XXX... 为上溢，需做溢出判断；
\[E\]<sub>补</sub> = 10,XXX... 为下溢，按机器 0 处理。

## 8.6 IEEE 754 标准浮点数的加减运算

上面的浮点数加减过程是一般化的计算过程。具体到`IEEE 754`浮点数的计算，流程一样，但是有些地方不同。下面我们举一个 X + Y 的例子，
其中 X = 0.1，Y = 0.2，假设 X 和 Y 是双精度浮点数。

X：`0 01111111011 1001100110011001100110011001100110011001100110011010`  
Y：`0 01111111100 1001100110011001100110011001100110011001100110011010`

### 8.6.1 对阶

1. 为了减少精度的损失，我们将尾数移除的数字进行保留，供以后的舍入（第四部分）处理。
2. X 的阶码为`01111111011`，Y 的阶码为`01111111100`。
3. 计算 01111111011 - 01111111100 转为补码计算的加法01111111011 + (-01111111100) = 01111111011 + 10000000100<sub>补</sub>。
得出的结果转为原码 11111111111<sub>补</sub> = -1<sub>10</sub>
4. 由于得知 X 与 Y 的阶差为 -1,所以我们需要将小阶 X 的尾数右移一位。原 X 的尾数部分`1001100110011001100110011001100110011001100110011010`，
右移后 X 的尾数`1100110011001100110011001100110011001100110011001101-0`。右移移位后，**尾数最高位为隐藏位的1**，
舍去移除的 0，最后得到 X 的尾数部分为:`1100110011001100110011001100110011001100110011001101`。

可以看到，流程和之前一般化的计算过程大致相同，也是阶码的补码运算。只是因为最高隐藏位为 1，所以移码的过程有所不同。

### 8.6.2 尾数计算

由于已经对阶完成，我们只需要将 52 位尾数部分和 1 位隐藏位进行加减计算。

> 如果隐藏位被右移了，那么默认补 0

```
X   0.1100110011001100110011001100110011001100110011001101
Y + 1.1001100110011001100110011001100110011001100110011010
——————————————————————————————————————————————————————————
   10.0110011001100110011001100110011001100110011001100111
```

`10.0110011001100110011001100110011001100110011001100111`就是尾数计算后的结果。可以看到，多了对隐藏位的处理。
X 之前由于隐藏位移位，现在它的隐藏位为 0。X + Y 倒置隐藏位进位变成 10<sub>2</sub>。

### 8.6.3 规格化

根据规格化的要求，我们需要将计算出的尾数右移 1 位，并将阶码加 1。
```
0  01111111101  0011001100110011001100110011001100110011001100110011(1)
```
这里计算后隐藏位还是继续隐藏。右移后的尾数为上面的数字，这里需要注意的是，最低位被右规了 1，造成精度丢失的问题。

### 8.6.4 舍入

根据 0 舍 1 入的规则，由于我们右规了 1 ，所以要进行加 1 的运算。
```
  0011001100110011001100110011001100110011001100110011
+ 0000000000000000000000000000000000000000000000000001
——————————————————————————————————————————————————————
  0011001100110011001100110011001100110011001100110100
```

### 8.6.5 溢出判断

阶码`01111111101`是没有发生上下溢出的情况的。所以舍入后的结果为最终的尾数部分。`IEEE-754`浮点数的上下溢出规则和之前有所不同，
上溢则视情况转为`+∞`或`-∞`，下溢则会转成非规格化数。

### 8.6.6 结果

最终我们得到`IEEE-754`的浮点数`0 01111111101 0011001100110011001100110011001100110011001100110100`。
将它转换为 10 进制数得到`0.30000000000000004`。可以看出，`0.1 + 0.2`最终结果并不等于`0.3`，
浮点数运算是有误差的。

可以在[FloatingNumberTest.java][test]中查看此运算在`Java`中的结果。

# 9. 浮点数精度和误差

浮点数不能表示所有实数。而且浮点数不仅在实数的表示上存在误差，在数值运算上也存在误差。两个双精度数之间的最小相对误差是
![](http://latex.codecogs.com/gif.latex?2^{-53}\approx1.11\times10^{-16})，所以只能保证 15 位精确数字，
第 16 位只是部分精确。单精度最小误差是![](http://latex.codecogs.com/gif.latex?2^{-24}\approx5.96\times10^{-8})，
所以只能保证 7 位精确数字，第 8 位只是部分精确。这里的有效位指的是从最高位(非 0)到最低位(非 0)的个数。

[FloatingNumberTest.java][test]对浮点数的精度和精度间隔做了详细的验证。

## 9.1 一些误差例子

1. `1.4 - 1.1 = 0.2999999999999998`。为什么不是`0.3`？  
    `1.4`和`1.1`两个数都不能被精确表示，用[binarycovert][convert]可以将浮点数字面量转换成真实存储的值，
    可以看到`1.4`被近似成了`1.399999999999999`，`1.1`被近似成了`1.10000000000000008`。
    所以两数相减得到的不是`0.3`而是`0.2999999999999998`。
2. `4.0 + 1e+16 - 1e+16 = 4.0`。没错。
3. `5.0 + 1e+16 - 1e+16 = 4.0`。为什么`5`变成了`4`？  
    双精度数第 16 位只是部分精确。`4.0`在对阶过程中没有丢失精度，而`5.0`在对阶过程中损失了精度。
4. `4.0 + 1e+17 - 1e+17 = 0.0`。为什么结果是`0.0`？`4`去哪里了？  
    `4.0 + 1e+17`的结果中的`4`已经在第 17 位，超出了双精度浮点数的最大有效位数，就被忽略了。
    
可以在[FloatingNumberTest.java][test]中查看这些运算在`Java`中的误差。

## 9.2 建议

1. 避免相近的两数相减  
    例如`a1 = 0.12345, a2 = 0.12346`，各有 5 位有效数字,而`a2 - a1 = 0.00001`，只剩下 1 位有效数字，容易造成相对误差增大，
    严重影响最终计算精度。
2. 避免小分母  
    例如单精度浮点数，阶码表示的范围是 -126~127，分母过小，分母和分子的阶码叠加，可能造成浮点数的溢出。
3. 避免大数吃小数  
    在浮点运算中，要对阶操作，有可能造成小数有效数字溢出，影响结果。
4. 简化运算步骤。  
    减少运算次数(运算量)，避免误差积累。
    
<!-- TODO: 减法、乘除 -->


[format]: ../../../res/img/float-format.png
[float]: ../../../res/img/float-float.jpg
[double]: ../../../res/img/float-double.jpg
[test]: ../../../test/java_/lang/FloatingNumberTest.java
[convert]: http://www.binaryconvert.com/result_float.html
[range]: ../../../res/img/float-range.png

<b id="f1">\[1\]</b> 参考 https://binarylife.icu/articles/735?unapproved=36&moderation-hash=17a01da8e4be8eb4105c3f9c06eedb8a#comment-36。 [↩](#a1)  
<b id="f2">\[2\]</b> David A. Patterson, and John L. Hennessy. Computer organization and design: the hardware/software interface. Newnes, 2013. [↩](#a2)  
<b id="f3">\[3\]</b> David Goldberg. "What every computer scientist should know about floating-point arithmetic." ACM Computing Surveys (CSUR), vol.23, no.1. pp.5-48, 1991. [↩](#a3)