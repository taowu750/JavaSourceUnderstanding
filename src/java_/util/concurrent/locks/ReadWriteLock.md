`java.util.concurrent.locks.ReadWriteLock`接口的声明如下：
```java
public interface ReadWriteLock
```
读写锁(`ReadWriteLock`)维护一对关联锁，一个用于只读操作，一个用于写。只要没有写入者，读锁可以由多个读者线程同时持有。
写锁是独占的。

所有的 `ReadWriteLock` 实现都必须保证 `writeLock` 操作的内存同步效果（如 `Lock` 接口中所指定的）对关联的 `readLock` 也是成立的。
也就是说，成功获取读锁的线程将看到之前释放写锁时的所有更新。

与互斥锁相比，读写锁允许在访问共享数据时有更大程度的并发性。它利用了这样一个事实：虽然每次只有一个线程（写线程）
可以修改共享数据，但在很多情况下，任何数量的线程都可以并发地读取数据（因此是读者线程）。

理论上，使用读写锁将比使用互斥锁带来性能的提升。实际上，这种并发性的增加只有在多处理器上才能完全实现，
然后只有在共享数据的访问模式合适的情况下才能实现。

读写锁是否会比使用互斥锁提高性能，取决于数据被读取与被修改的频率、读写操作的持续时间，以及对数据的争夺--也就是同时尝试读取或写入数据的线程数量。
例如，一个最初被数据填充，此后不经常被修改，同时又经常被搜索的集合（如某种目录）是使用读写锁的理想候选者。然而，
如果更新变得频繁，那么数据的大部分时间都被专门锁定，并发性几乎没有增加，甚至没有增加。此外，如果读操作时间太短，
读写锁实现的开销(本质上比互斥锁更复杂)会决定大多数执行成本，特别是许多读写锁实现仍然通过一小段代码将所有线程序列化。
最终，只有通过剖析和测量才能确定读写锁的使用是否适合你的应用。

虽然读写锁的基本操作是直截了当的，但有许多策略决定是一个实现必须做出的，这可能会影响读写锁在特定应用中的有效性。
这些策略的例子包括：
 - 当读取线程和写入线程都在等待的时候，如果一个写入线程释放写锁的时候，是授予读锁还是写锁？写者优先是很常见的，
 因为预计写的时间很短且不频繁。读者偏好不那么常见，因为如果读者像预期的那样频繁和长寿，就会导致写的长时间延迟。
 公平的，或者说 "按顺序 "的实现也是可能的。
 - 确定在读者处于活动状态而写者正在等待时，请求读锁的读者是否被授予读锁？优先于读者可以无限期地延迟写入者，
 而优先于写入者会减少并发的可能性。
 - 判断锁是否可重入：拥有写锁的线程能否重新获取锁？在持有写锁的同时能否获取读锁？读锁本身是否是可重入的？
 写锁能否降级为读锁而不允许有写者介入？能否将读锁升级为写锁，优先于其他等待的读者或写者？

在评估一个给定的实现是否适合你的应用时，你应该考虑所有这些事情。

# 1. 方法

## 1.1 readLock
```java
// 返回读锁
Lock readLock();
```

## 1.2 writeLock
```java
// 返回写锁
Lock writeLock();
```