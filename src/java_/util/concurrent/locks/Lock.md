`java.util.concurrent.locks.Lock`接口的声明如下：
```java
public interface Lock
```
与使用同步方法和语句相比，`Lock` 的实现提供了更广泛的锁定操作。它们允许更灵活的结构，可能具有完全不同的属性，
并且可能支持多个关联的 `Condition` 对象。

`Lock` 是控制多个线程访问共享资源的工具。通常情况下，`Lock` 提供了对共享资源的独占性访问：一次只能有一个线程获得锁，
对共享资源的所有访问都需要先获得锁。但是，有些锁可能允许并发访问共享资源，比如 `ReadWriteLock` 的读锁。

同步方法或语句的使用提供了对与每个对象相关联的隐式监控锁的访问，但迫使所有锁的获取和释放以块结构的方式进行：
当获取多个锁时，它们必须以相反的顺序释放，而且所有锁必须在获取它们的同一个作用域中释放。

虽然同步方法和语句的作用域机制使得使用监控锁进行编程变得更加容易，并有助于避免许多涉及锁的常见编程错误，但在某些场合，
你需要以更灵活的方式使用锁。例如，一些用于遍历并发访问数据结构的算法需要使用 "hand-over-hand" 或 "chain locking"：
你先获取节点 A 的锁，然后获取节点 B 的锁，再释放 A 并获取 C，然后释放 B 并获取 D，以此类推。
`Lock` 接口的实现通过允许在不同的范围内获取和释放一个锁，并允许以任何顺序获取和释放多个锁，从而实现了这种算法。

随着这种灵活性的增加，也带来了额外的责任。块结构化锁的缺失消除了同步方法和语句所发生的锁的自动释放。
在大多数情况下，应该使用下面的方式。
```java
Lock l = ...;
l.lock();
try {
    // 访问受该锁保护的资源
} finally {
    l.unlock();
}
```

当锁定和解锁发生在不同的作用域时，必须注意确保在锁被持有时执行的所有代码都受到 `try-finally` 或 `try-catch` 的保护，
以确保在必要时释放锁。

`Lock` 的实现提供了比使用同步方法和语句更多的功能，它提供了一个非阻塞的获取锁的尝试(`tryLock()`)，
一个可以被中断的获取锁的尝试(`lockInterruptibly`)，以及一个可以超时的获取锁的尝试(`tryLock(long，TimeUnit)`)。

一个 `Lock` 类还可以提供与隐式监视器锁完全不同的行为和语义，例如保证排序、非重入使用或死锁检测。
如果一个实现提供了这样的专门语义，那么该实现必须将这些语义记录下来。

注意，`Lock` 实例只是普通的对象，其本身可以作为同步语句中的目标。
获取 `Lock` 实例的监控锁与调用该实例的任何锁方法没有指定的关系。为了避免混淆，建议你永远不要以这种方式使用 `Lock` 实例，
除非在它们自己的实现中。

除非有说明，否则为任何参数传递一个空值将导致 `NullPointerException` 被抛出。

所有的 `Lock` 实现都必须强制执行与内置监控锁所提供的相同的**内存同步语义**，正如 Java 语言规范（17.4 内存模型）中所描述的那样。
 - 一个成功的锁操作与一个成功的 `Lock` 操作具有相同的内存同步效果。
 - 一个成功的解锁操作与一个成功的 `UnLock` 操作具有相同的内存同步效果。
 - 不成功的锁定和解锁操作，以及重入锁定/解锁操作，不需要任何内存同步效果。

三种形式的锁获取(可中断、不可中断和定时)可能在其性能特征、订购保证或其他实现质量上有所不同。此外，在一个给定的 `Lock` 类中，
中断正在进行的锁获取的能力可能是不可用的。因此，一个实现不需要为所有三种形式的锁获取定义完全相同的保证或语义，
也不需要支持中断正在进行的锁获取。一个实现需要清楚地记录每一种锁方法所提供的语义和保证。它还必须服从本接口中定义的中断语义，
在支持中断锁获取的范围内：要么是完全中断，要么是仅在方法进入时中断。

由于中断一般意味着取消，而对中断的检查通常不频繁，因此，一个实现可以倾向于响应中断而不是正常的方法返回。
即使可以证明中断发生在另一个操作可能已经解除线程阻塞之后，也是如此。实现应该记录这种行为。

# 1. 方法

## 1.1 lock
```java
/*
获取锁。如果锁不可用，那么出于线程调度的目的，当前线程将被禁用，并处于休眠状态，直到锁被获取。

一个 Lock 实现可能能够检测到对锁的错误使用，例如会导致死锁的调用，并可能在这种情况下抛出一个未检查的异常。
这种情况和异常类型必须由该 Lock 实现记录下来。
*/
void lock();
```

## 1.2 lockInterruptibly
```java
/*
除非当前线程被打断，否则获取锁。
1. 如果锁可用，则获取锁并立即返回。
2. 如果锁不可用，那么出于线程调度的目的，当前线程就会被禁用，并处于休眠状态，直到下面两种情况之一发生。
    - 锁定被当前线程获取；
    - 其他一些线程中断当前线程，而锁实现支持中断锁。

如果当前线程：
 - 在进入本方法时设置了中断状态；
 - 或在获取锁的同时被中断，而锁实现支持中断锁。
则会抛出 InterruptedException，并清除当前线程的中断状态。

在某些实现中，中断锁的获取是不可能的，如果可能的话，将会是一个昂贵的操作。程序员应该意识到可能会出现这种情况。
在这种情况下，实现应该记录在文档中。

一个实现可以倾向于响应一个中断而不是正常的方法返回。一个 Lock 实现可能能够检测到对锁的错误使用，
例如会导致死锁的调用，并可能在这种情况下抛出一个未检查的异常。这种情况和异常类型必须由该 Lock 实现记录在文档中。
*/
void lockInterruptibly() throws InterruptedException;
```

## 1.3 tryLock
```java
/*
只有在调用时锁没有被其它线程持有的情况下才会获取锁。
如果锁是可用的，则获取锁，并立即返回 true。如果锁是不可用的，那么本方法将立即返回 false。

这个方法的典型用法是这样的：  
 Lock lock =
 if (lock.tryLock()) { {
   try
     // 操作受保护状态
   } finally {
     lock.unlock();
   }
 } else {
   // 执行替代行动
 }
这种用法可以确保如果获得了锁就会解锁，如果没有获得锁就不会尝试解锁。
*/
boolean tryLock();

/*
如果在给定的等待时间内锁是空闲的，并且当前线程没有被中断，则获取锁。
如果锁是可用的，那么这个方法立即返回 true。如果锁不可用，那么出于线程调度的目的，当前线程将被禁用，
并处于休眠状态，直到三种情况之一发生。
 - 锁被当前线程获取；
 - 其他一些线程中断当前线程，而锁实现支持中断锁；
 - 指定的等待时间已过。
如果获得了锁，那么返回 true。

如果当前线程在进入本方法时：
 - 设置了中断状态；
 - 或在获取锁的同时被中断。
则会抛出 InterruptedException，并清除当前线程的中断状态。

如果指定的等待时间过去了，那么返回 false。如果时间小于或等于零，则该方法将完全不等待。

在某些实现中，中断锁的获取是不可能的，如果可能的话，将会是一个昂贵的操作。程序员应该意识到可能会出现这种情况。
在这种情况下，实现应该记录在文档中。

一个实现可以倾向于响应一个中断而不是正常的方法返回。一个 Lock 实现可能能够检测到对锁的错误使用，
例如会导致死锁的调用，并可能在这种情况下抛出一个未检查的异常。这种情况和异常类型必须由该 Lock 实现记录在文档中。
*/
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
```

## 1.4 unlock
```java
/*
释放锁。

一个 Lock 实现通常会对哪个线程可以释放锁施加限制（通常只有锁的持有者可以释放锁），如果违反了限制，
可能会抛出一个未检查的异常。任何限制和异常类型都必须由该 Lock 实现记录在文档中。
*/
void unlock();
```

## 1.5 newCondition
```java
/*
返回一个新的 Condition 实例，该实例绑定在这个 Lock 实例上。

调用 Condition.await() 将在等待之前原子性地释放锁，并在等待返回之前尝试重新获取锁。
在等待 Condition 之前，锁必须由当前线程持有。

Condition 实例的具体操作取决于 Lock 的实现，并且必须由该实现记录在文档中。
*/
Condition newCondition();
```