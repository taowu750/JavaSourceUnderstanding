# 1. Java 对象模型

我们先了解一下，一个 JAVA 对象的存储结构。在 HotSpot 虚拟机中，对象在内存中的存储布局分为 3 块区域：
 - 对象头（Header）。
 - 实例数据（Instance Data）。
 - 对齐填充（Padding）。

如下图所示：

![对象头][header]

## 1.1 对象头（Header）

对象头，又包括三部分：MarkWord、元数据指针、数组长度。下表列出了对象头的内容：

| 长度 | 内容 | 说明 |
| ---- | --- | ---- |
| 32/64 bit | MarkWord | 存储对象的 hashCode 或锁信息等 |
| 32/64 bit | Class Metadata Address | 存储对象类型数据的指针 |
| 32/64 bit | Array Length | 数组的长度(如果当前对象是数组) |

对于指向它的类元数据的指针，这部分就涉及到一个指针压缩的概念。在 64 位 JVM 中，开启指针压缩的情况下，它占 4 字节（32bit），
未开启情况下，占 8 字节（64bit）。现在 JVM 在 1.6 之后，在 64 位操作系统下都是默认开启的。
指针压缩后的这四个字节最大可以映射 32GB 的内存。

## 1.2 实例数据（Instance Data）

用于存储对象中的各种类型的字段信息（包括从父类继承来的）。

## 1.3 对齐填充（Padding）

Java 对象的大小默认是按照 8 字节对齐，也就是说 Java 对象的大小必须是 8 字节的倍数。
如果算到最后不够 8 字节的话，那么就会进行对齐填充。那么为什么非要进行 8 字节对齐呢？这样岂不是浪费了空间资源？

其实在 JVM 中（不管是 32 位的还是 64 位的），对象已经按 8 字节边界对齐了。对于大部分处理器，这种对齐方案都是最优的。
如果 JVM 中的第一个对象保存到位置 0，占用 57 字节，那下一个对象就要保存到位置 64，浪费了 7 字节，
无法再分配。这种内存取舍是值得的，因为在 8 字节对齐的位置，对象可以更快地访问。

也就说，8 字节对齐，是为了效率的提升，以空间换时间的一种方案。

# 2. 指针压缩原理

为什么对象指针，可以用 8 字节存也可以用 4 字节存？4 字节存不会有什么问题吗？

## 2.1 不开启指针压缩

采用 8 字节（64 位）存储真实内存地址，比之前采用 4 字节（32 位）压缩存储地址带来的问题：
 - 增加了 GC 开销：64 位对象引用需要占用更多的堆空间，留给其他数据的空间将会减少，从而加快了 GC 的发生，更频繁的进行 GC。
 - 降低 CPU 缓存命中率：64 位对象引用增大了，CPU 能缓存的对象指针将会更少，从而降低了 CPU 缓存的效率。

## 2.2 开启指针压缩

既然 64 位存储内存地址，会导致了这么多问题，那么我们可以不可以找一种方法，既使用之前的 4 字节（32 位）存指针地址，
又可以扩大内存的方法呢？答案就是采用指针压缩技术！

4 个字节，32 位，可以表示 2<sup>32</sup> 个地址。如果这个地址是真实内存地址的话，那么由于 CPU 寻址的最小单位是 byte，
也就是 2<sup>32</sup> byte = 4GB。

但如果内存地址是指向 bit 的话，32 位的最大寻址范围就会是 512MB。由于内存里，将 8bit 为一组划分，
所以内存地址就其实是指向的 8bit 为一组的 byte 地址，所以 32 位可以表示的容量就扩充了 8 倍，就变成了 4GB。

而在 Java 的对齐填充机制中，Java 的 8 字节对齐填充，就像是内存的 8bit 为一组，变为 1byte 一样。这里的压缩指针，
不是真实的操作系统内存地址，而是 Java 进行 8byte 映射之后的地址，所以也相对于操作系统的指针有进行的 8 倍的扩容。
也就是 4GB * 8 = 32GB。Java 对象的指针地址就可以不用存对象的真实的 64 位地址了，而是可以存一个映射地址编号。

需要注意的是，当内存大于 32GB 时，开启指针压缩的参数会失效！所以建议大家在 64 位系统系下，JAVA 的堆内存设置最好不要超过 32GB，
一旦超过 32GB 后，指针压缩就会失效，然后带来 GC 的触发频次变高，而且造成空间浪费。

还有就是，32GB 是个近似值，这个临界值跟 JVM 和平台有关，当我们线上真正启动服务的时候直接设置 `-Xmx=32GB` 的时候很可能导致压缩指针失效，
那我们怎么确定当前环境下最大内存设置多大才，才能最大限度的使用内存并启用压缩指针呢？
我们可以通过增加 JVM 参数 `-XX:+PrintFlagsFinal`，验证 `UseCompressedOops` 的值，从而得知，到底是不是真的开启了压缩指针，
还是压缩指针失效。


[header]: ../../../../res/img/pointer-compress-header.png